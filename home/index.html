<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT, technology blog, open source blog, C++ blog" />










<meta property="og:type" content="website">
<meta property="og:title" content="DueGin">
<meta property="og:url" content="https://duegin.github.io/home/index.html">
<meta property="og:site_name" content="DueGin">
<meta property="og:locale">
<meta property="article:author" content="DueGin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://duegin.github.io/home/"/>





  <title>DueGin</title>
  








<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DueGin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/" itemprop="url">数论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-23T00:39:17+08:00">
                2021-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p>[TOC]</p>
<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>方法：</p>
<ul>
<li>试除法判定质数</li>
<li>试除法分解质因数</li>
<li>埃氏筛法求素数</li>
<li>线性筛法求素数</li>
</ul>
<h2 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h2><p>时间复杂度 $O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/868/">AcWing 866. 试除法判定质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 x 是否为质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断1和0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">//从1～sqrt(x)里找即可</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只需遍历到 $\sqrt{x}$ 的原因是：<br>一个数的因数都是<strong>成对存在的</strong>，即：<br>$d&lt;={x}/{d}$    $d^2&lt;=x$    $d&lt;=\sqrt{x}$</p>
<p>例如12的因数有3和4，2 和6，所以我们可以只枚举较小的那一个，即 $\sqrt{x}$ ，假设较小的为d，较大的为 x/d<br>其实我认为：$x$ 质因数边界就是 $\sqrt{x}$</p>
</blockquote>
<h2 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h2><p>时间复杂度：$O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/869/">AcWing 867. 分解质因数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 级数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#4">埃拉托斯特尼筛法</a>，简称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%B0%8F%E7%AD%9B/5677377">埃氏筛</a>或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于 $\sqrt{x}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>要得到自然数n以内的全部素数，必须把不大于 $\sqrt{n}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>时间复杂度 $O(nloglogn)$</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有质数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 筛选 2～n 的所有数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i; <span class="comment">// 将 i 存入质数数组中</span></span><br><span class="line">        <span class="comment">// 质数的倍数绝对不是质数，把所有质数的倍数全部丢弃</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) <span class="comment">// 将i的所有倍数筛掉，j就是几倍，而 n/i则是i的最大倍数，小学数学</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  给出要筛数值的范围n，找出以内的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个质数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个质数5筛，把5留下，把5的倍数剔除掉；不断重复下去……</p>
</blockquote>
<h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>线性筛法，也叫欧拉筛法，是在埃氏筛法的基础上做出优化，我们发现这里面似乎会对某些数标记了很多次其为合数，而线性筛法利用其最小质因数来筛掉合数，每次只标记一次</p>
<p>时间复杂度 $O(n)$ ，数据量小于1e7的情况下，线性筛法和埃氏筛法差不多，数据量大于1e7则线性筛法比埃氏筛法快一倍</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 用最小质因子去筛合数 primes[j] * i</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果 i 是合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(i%prime[j]==0) break;</code> 这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。</p>
<img src="/2021/12/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/线性筛法例子.png" alt="线性筛法例子" style="zoom:75%;">

<p>例如，$i=6$ 时，第一个素数是2，能整除，筛掉12后就 break；至于第二个素数3，6x3中的最小素因数肯定是前一个素数2，所以它要到 $i=9$，素数取2时才被筛掉。</p>
<ol>
<li><p>  当 <code>i%primes[j]!=0</code> 时，说明此时遍历到的 <code>primes[j]</code> 不是i的质因子，那么只可能是此时的 <code>primes[j]*i</code> 的最小质因子，所以 <code>primes[j]*i</code> 的最小质因子就是 <code>primes[j]</code></p>
</li>
<li><p>  当有 <code>i%primes[j]==0</code> 时，说明 i 的最小质因子是 <code>primes[j]</code> ， 因此 <code>primes[j]*i</code> 的最小质因子也就应该是 <code>prime[j]</code>，之后接着用 <code>st[primes[j+1]*i]=true</code> 去筛合数时，就不是用最小质因子去更新了，因为 i 有最小质因子 <code>primes[j]&lt;primes[j+1]</code>，此时的 <code>primes[j+1]</code>不是 <code>primes[j+1]*i</code> 的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</p>
</li>
</ol>
<blockquote>
<p>补充：一个数乘上合数肯定是合数，所以只需要让遍历到的数 i 乘上其最小质因数 <code>prime[j]</code> 即可，这样的话乘上后的数必是合数，且有质因数是 <code>prime[j]</code></p>
</blockquote>
<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>方法：</p>
<ul>
<li>试除法求所有约数</li>
<li>约数个数 和 约数之和</li>
<li>欧几里得算法</li>
</ul>
<p>n 与 1～n 的约数互为质数的个数：</p>
<ul>
<li>朴素求欧拉函数</li>
<li>筛法求欧拉函数</li>
</ul>
<h2 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h2><p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/871/">AcWing 869. 试除法求约数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回升序的x所有质数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  因为约数都是成对存在的，所以只需要遍历到 $\sqrt{x}$ 即可，具体看<strong>试除法求质数</strong></p>
</blockquote>
<blockquote>
<p>  第9行：防止当约数重复加入，如25=5*5</p>
</blockquote>
<h2 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86/4926961">约数个数定理</a> </p>
<p>乘法原理，组合数学</p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$</p>
<p>约数个数： $(c_1 + 1) \times (c_2 + 1) \times … \times (c_k + 1)$ </p>
<p>可以发现：约数个数和质因数是啥无关</p>
<blockquote>
<p>  百科例题：正整数 378000 共有多少个正约数？</p>
<p>  解：将 378000 分解质因数$378000=2^4×3^3×5^3×7^1$</p>
<p>  由约数个数定理可知378000共有正约数$(4+1)×(3+1)×(3+1)×(1+1)=160$个。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/872/">AcWing 870. 约数个数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x/i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h:m) res = <span class="built_in">res</span>  (h.second+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  这里的扫尾是因为，有可能最后除到 $x$ 是质数了，比如 7 或14 最后只能由扫尾加入 7 这个质因数</p>
</blockquote>
<h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428">约数和定理</a> </p>
<p>模板题： <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/873/">AcWing 871. 约数之和</a> </p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>约数之和： $(p_1^0 + p_1^1 + … + p_1^{c_1}) \times … \times (p_k^0 + p_k^1 + … + p_k^{c_k})$ </p>
<blockquote>
<p>  百科例题：正整数360的所有正约数的和是多少？</p>
<p>  解：将360分解质因数可得</p>
<p>  $360=2^3<em>3^2</em>5^1$</p>
<p>  由约数和定理可知，360所有正约数的和为</p>
<p>  $(2^0+2^1+2^2+2^3)×(3^0+3^1+3^2)×(5^0+5^1)=(1+2+4+8)(1+3+9)(1+5)=15×13×6=1170$</p>
<p>  可知360的约数有1、2、3、4、5、6、8、9、10、12、15、18、</p>
<p>  20、24、30、36、40、45、60、72、90、120、180、360；则它们的和为</p>
<p>  1+2+3+4+5+6+8+9+10+12+15+18+20+24+30+36+40+45+60+72+90+120+180+360=1170</p>
</blockquote>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x/i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h:m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p=h.first,c=h.second; <span class="comment">// a是底数，b是级数</span></span><br><span class="line">    LL t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c--) t=t*p+<span class="number">1</span>; <span class="comment">// pi^(0~ak)之和，也可以用等比求和</span></span><br><span class="line">    res*=t; <span class="comment">// 所有pi相乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="欧几里得算法（最大公约数）"><a href="#欧几里得算法（最大公约数）" class="headerlink" title="欧几里得算法（最大公约数）"></a>欧几里得算法（最大公约数）</h2><p>原理：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a></p>
<p>也叫辗转相除法</p>
<blockquote>
<p>  百科例子：</p>
<p>  假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：</p>
<p>  1997 / 615 = 3 (余 152)</p>
<p>  615 / 152 = 4(余7)</p>
<p>  152 / 7 = 21(余5)</p>
<p>  7 / 5 = 1 (余2)</p>
<p>  5 / 2 = 2 (余1)</p>
<p>  2 / 1 = 2 (余0)</p>
<p>  至此，最大公约数为1</p>
<p>  以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/874/">AcWing 872. 最大公约数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  这里a 和 b无论谁大都可用，我试过了</p>
</blockquote>
<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>定理：</p>
<p>$(a,b) \times [a,b]=a \times b$</p>
<p>即需要用到 $gcd(a,b)$ 先求出最大公约数，再用两数之积除以 $d$</p>
<h2 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h2><p>在数论，对正整数 n，欧拉函数是小于 n 的正整数中与 n <a href="%E4%BA%92%E8%B4%A8%E6%98%AF%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E6%95%B4%E6%95%B0%E3%80%82%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%90%8E%E8%80%85%E6%98%AF%E5%89%8D%E8%80%85%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E3%80%82">^互质</a>的数的数目。</p>
<p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850">欧拉函数</a> 容斥原理</p>
<img src="/2021/12/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/容斥原理.png" alt="容斥原理" style="zoom:61%;">

<p>N的质因数分解： $N=p_1^{c_1}\times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>与 N 互质的数的个数<strong>结论</strong>：</p>
<p> $φ(N)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ </p>
<p>​             $=N \times \frac{p_1-1}{p_1} \times \frac{p_2-1}{p_2}…\frac{p_k-1}{p_k}$ </p>
<p>可以发现：<strong>欧拉函数与质因数的级数无关</strong> </p>
<h3 id="朴素求法"><a href="#朴素求法" class="headerlink" title="朴素求法"></a>朴素求法</h3><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/875/">AcWing 873. 欧拉函数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 试除法求质因数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除后乘，防止溢出</span></span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>这个思路是利用了线性筛法来求欧拉函数，代码也在线性筛法的基础上作出了小修改，在求质因数的时候，用其最小质因数去更新其欧拉函数</p>
<p>思路（类似DP）：</p>
<ul>
<li>  先写出线性筛法模板</li>
<li>  多开一个 $euler[N]$ 数组存每个数的欧拉函数</li>
<li>分情况<ul>
<li>被筛掉的情况<ul>
<li>  被筛掉说明是质数，那他的欧拉函数就是 $i-1$ </li>
</ul>
</li>
<li>筛选时的情况<ul>
<li>  $primes[j]$ 为 $primes[j] \times i$ 的最小质因数</li>
<li><code>i % p[j] == 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times primes[j]$ </li>
</ul>
</li>
<li><code>i % p[j] != 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times (primes[j]−1)$ </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面 $primes[j]$ 用 $p[j]$ 表示</p>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>   $φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ 是 $i$ 的一个质因子，而且欧拉函数与质因子个数无关，所以在算 $p[j]\times i$ 分解质因子也是 $p_1 -&gt; p_k$ </p>
<p>  因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) $ </p>
<p>  即： $φ(p[j]\times i)=p[j]\times φ(i) $ </p>
</blockquote>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>$φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ <strong>不是</strong> $i$ 的一个质因子，所以 $p[j]\times i$ 与 $i$ 的质因子的区别就是前者比后者多一个 $p[j]$ </p>
<p>因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) \times (1-\frac{1}{p_j})$  </p>
<p>即： $φ(p[j]\times i)=p[j]\times φ(i) \times (1-\frac{1}{p_j})$ </p>
<p>即： $φ(p[j] \times i)=φ(i) \times (p[j]−1)$ </p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/876/">AcWing 874. 筛法求欧拉函数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 线性筛法求欧拉函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>; <span class="comment">// 质数的话，肯定是前面的数，除了0以外互质的数只有1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ ) <span class="comment">// 遍历质数，用最小质因数筛掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i; <span class="comment">// 质数*i </span></span><br><span class="line">            st[t] = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// 用最小质因数去更新其欧拉函数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">// i % p[j] == 0的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j]; <span class="comment">// 直接乘上其最小质因数的欧拉函数即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i % p[j] != 0的情况</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">// 这里是化简后的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  当 $i$ 未被标记时，即 $i$ 为质数，那肯定是前面的数，除了0以外只有1是互质的数</p>
</blockquote>
<p>背过吧…</p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>求 $a^k$  mod  $p$，时间复杂度 $O(logk)$ </p>
<p><strong>数学结论：</strong></p>
<p>传统方法是直接将 $a$ 乘 $b$ 次，但是算法复杂度是 $O(b)$ ，如果遇到 $b$ 很大的情况就很慢。</p>
<p>其实就是把幂转成二进制，然后来算</p>
<p>$$a^k=a^{2 \frac{k}{2}}=(a^2)^{\frac{k}{2}}$$ </p>
<p>如果把 k 转成二进制数 $(k)_{10}=(…bcd)_2$ </p>
<p>那么：<br> $$a^k=a^{d \  \cdot \ 2^0 + c \ \cdot \ 2^1 + b\ \cdot \ 2^2+ \ …}$$ </p>
<p> $$a^k=a^{d \  \cdot \ 2^0} \cdot a^{c \  \cdot \ 2^1} \cdot a^{b \  \cdot \ 2^3} \ …$$ </p>
<p>可以发现其实就是将幂拆成用二进制表示幂来算</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/877/">AcWing 875. 快速幂</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a^k%p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>,t = a;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) <span class="comment">// 取二进制个位</span></span><br><span class="line">            res = (LL)res * t % p; <span class="comment">//  把每一项乘起来</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">// k把个位去掉（右移一位）</span></span><br><span class="line">        t = (LL)t * t % p; <span class="comment">// 这个就是每一次的(a^2)的级数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  例子：</p>
<p>  求$5^{11}$</p>
<p>   $$5^{11}=5^{(1011)_2}$$ </p>
<p>   ​       $$=5^{2^3+2^1+2^0}$$ </p>
<p>  ​       $$=5^{2^3} \ \cdot \ 5^{2^1} \ \cdot \ 5^{2^0}$$ </p>
<p>  ​       $$=5^{8} \ \ \cdot \ 5^{2} \ \ \cdot \ 5^{1}$$ </p>
</blockquote>
<p>如此可以发现，与幂的二进制数上的每一位有关</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p> 给定一对正整数 a,b，求出一组 x,y，使其满足：</p>
<p> $$ax+by=gcd(a,b)$$</p>
<blockquote>
<p>贝祖定理：<br>​有一个线性不定方程<br>$ax+by=c$</p>
<p>若此方程有解，那么<br>$c=k·(a,b), k∈Z^+$ </p>
</blockquote>
<p>公式推导：</p>
<p>当 $b=0$ 时 $ax+by=a$ 故而 $x=1,y=0$，</p>
<p>当 $b≠0$ 时，因为<br>$$gcd(a,b)=gcd(b,a%b)$$<br>而<br>$$bx′+(a%b)y′=gcd(b,a%b)$$<br>$$bx′+(a−⌊a/b⌋\times b)y′=gcd(b,a%b)$$<br>$$ay′+b(x′−⌊a/b⌋\times y′)=gcd(b,a%b)=gcd(a,b)$$</p>
<p>故而求得<strong>通解</strong>：<br>$$x=y′,y=x′−⌊a/b⌋\times y′$$</p>
<p>因此可以采取递归算法 先求出下一层的 $x′$ 和 $y′$ 再利用上述公式回代即可</p>
<p>递归边界：当 $b=0$ 时，$(a,b)=a,x=1,y∈Z$</p>
<blockquote>
<p>特别的，用扩展欧几里得算法还可以求出乘法逆元。<br>$$ax≡1mod \ p$$ <br>$$ax+py=1$$</p>
<p>当且仅当 $gcd(a,p)=1$ 时有解。</p>
</blockquote>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/879/">AcWing 877. 扩展欧几里得算法</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// 返回值是 a 和 b 的最大公约数，即: gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="comment">// 这是其中一组解</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>; <span class="comment">// 边界，当b=0时，手算出来的边界，a*x + 0*y = gcd(a, 0) = a</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">// 先求出下一层递归的 y = x&#x27; 和 x = y&#x27;</span></span><br><span class="line">    y -= (a / b) * x; <span class="comment">// y=x&#x27;−⌊a/b⌋*y&#x27;，这里的x&#x27;其实就是下一层递归的x，y&#x27;是下一层的y，因为上面交叉传了</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h2><blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  对任何整数 $a$、$b$ 和它们的最大公约数 $d$ ，满足：</p>
<p>  ​                                                                $$ax+by=d$$</p>
<p>  若$a$, $b$是整数，且 $gcd(a,b)=d$，那么对于任意的整数 $x$, $y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$, $y$，使得$ax+by=d$ 成立。</p>
</blockquote>
<p>当算一个线性同余方程 $ax_0+by_0=d$ 的通解时，我们可以发现 $a(x-\frac{b}{d})+b(y+\frac{a}{d})=d$ 为其中一组解</p>
<p>即其通解为：</p>
<p>​                                                                                        $$x=x_0-\frac{b}{d} \cdot k \ ,k∈Z$$</p>
<p>​                                                                                         $$y=y_0+\frac{a}{d} \cdot k \ , k∈Z$$</p>
<p>给定 $a$, $b$, $p$，求出 $x$ 使其满足</p>
<p>​                                                                        $$a \cdot x≡b \ mod \ p$$</p>
<p> 这个方程可以写为</p>
<p>​                                                                         $ax=py+b$  ，  将 $y = -y$ </p>
<p>即： $ax+py=b$</p>
<p>要使该方程有解，则满足</p>
<p>​                                                                        $$b=k \cdot gcd(a,p),k∈Z$$</p>
<p>用扩展欧几里得算法求出 $ax+py=(a,p)$ 的 $x$ 的解之后，再将 $x$ 乘上 $\frac{b}{(a,p)}$ 即可。</p>
<p>为什么要翻倍，因为我们需要求的是 $ax+py=b$ ，而 $(a,p)$ 是 $b$ 的倍数，所以两边同时翻倍即可</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/880/">AcWing 878. 线性同余方程</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// b不是d的倍数则无解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * b / d % p; <span class="comment">// 扩大b/d倍</span></span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exgcd()</code>照套就行</p>
<h1 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h1><p>逆元定义</p>
<blockquote>
<p>  若整数 $b$，$p$ 互质，并且对于任意的整数 $a$，如果满足 $b|a$，则存在一个整数 $x$，使得 $a/b≡a\cdot x \ (mod\ p)$，则称 $x$ 为 $b$ 的模 $p$ 乘法逆元，记为 $b^{−1} \ (mod \ p)$。</p>
<p>  $b$ 存在乘法逆元的充要条件是 $b$ 与模数 $p$ 互质。当模数 $p$ 为质数时，$b^{p−2}$ 即为 $b$ 的乘法逆元。</p>
</blockquote>
<blockquote>
<p>  百科例子：4关于1模7的乘法逆元为多少？</p>
<p>  $4X≡1 \ mod \ 7$ </p>
<p>  这个方程等价于求一个X和K，满足</p>
<p>  $4X=7K+1$</p>
<p>  其中X和K都是整数。</p>
</blockquote>
<blockquote>
<p>  <strong>费马小定理</strong>：如果 $p$ 是一个质数，而整数 $b$ 不是 $p$ 的倍数，则有$b^{p-1}≡1 \ (mod \ p)$ </p>
<p>  满足费马小定理，则有此结论： $b^{p-2}$ 就是 $b$ 的逆元</p>
</blockquote>
<blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  特别的，如果 $bx+py=1$ 即可以转换成扩展欧几里得算法来求解 $x$，即为 $b$ 的逆元</p>
</blockquote>
<p><strong>数学结论：</strong></p>
<ul>
<li><p>  $b$ 有逆元的充要条件是 $b$ 与 $p$ 互质</p>
</li>
<li><p>当 $p$ 为质数时，可用快速幂求逆元</p>
<ul>
<li><p>  $b$ 的乘法逆元为 $b^{p-2}$ ，<code>qmi(b, p - 2, p)</code></p>
</li>
<li><p>  当 $b$ 为 $p$ 的倍数时，**$b$ 的逆元不存在**， $b \cdot x%p==0$ ，$b$ 乘任意一个 $x%p$ 一定等于0</p>
</li>
</ul>
</li>
<li><p>当 $p$ 不为质数时，只能用扩展欧几里得算法求逆元</p>
<ul>
<li>当 $bx+py=1$ 时，$x$ 即为 $b$ 的逆元</li>
</ul>
</li>
</ul>
<p><strong>当 $p$ 为质数时，可以用快速幂求逆元的推导：</strong></p>
<p>$$a / b ≡ a * x \ (mod \ p)$$ </p>
<p>两边同乘 $b$ 可得 $a ≡ a * b * x \ (mod \ p)$ </p>
<p>同除 $a$ 即 $1 ≡ b * x \ (mod \ p)$ </p>
<p> $b * x ≡ 1 \ (mod \ p)$ </p>
<p>由费马小定理可知，当 $p$ 为质数时</p>
<p>$b ^ {n - 1} ≡ 1 \ (mod \ p)$ </p>
<p>拆一个 $b$ 出来可得 $b * b ^ {n - 2} ≡ 1 \ (mod \ p)$ </p>
<p>故当 $p$ 为质数时，$b$的乘法逆元 $x = b ^ {p - 2}$ </p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/878/">AcWing 875. 快速幂求逆元</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b % p == <span class="number">0</span>) <span class="comment">// b能整除p说明，b和p不互质，即 b mod p的逆元不存在</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qmi</span>(b, p<span class="number">-2</span>, p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p><strong>当 $p$ 不是质数时，用扩展欧几里得算法求逆元：</strong></p>
<p>$b$ 有逆元的充要条件是 $b$ 与 $p$ 互质，所以 $gcd(b, p) = 1$</p>
<p>假设 $b$ 的逆元为 $x$，那么有 $b * x ≡ 1 \ (mod \ p)$</p>
<p>等价： $bx + py = 1$ </p>
<p>$exgcd(b, p, x, y)$ </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) cout &lt;&lt; ((LL)x + p) % p; 当且仅当 (a,p)=<span class="number">1</span> 时有解。</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>求一元线性同余方程组</p>
<p><strong>定义：</strong></p>
<p>给定一组线性同余方程组，求出 $x$ 最小非负整数解：<br>                                                                $$x≡a_1 \ mod \ m_1 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                            $$⋮ $$<br>                                                                            $$⋮ $$<br>                                                                $$x≡a_n \ mod \ m_n$$</p>
<blockquote>
<p>  <strong>中国剩余定理：</strong></p>
<p>  设 $M=m_1 \times m_2 \times … \times m_n = \prod_{i=1}^{n}{m_i}$ ，$M_i=\frac{M}{m_i}$ 是除了<em>m</em>i以外的<em>n</em>- 1个整数的乘积，$M_i^{-1}$ 是 $M_i$ 模 $m_i$ 意义下的逆元。</p>
<p>  则方程组的通解为</p>
<p>   $x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_nM_nM_n^{-1}+kM=kM+\sum_{i=1}^{n}a_iM_iM_i^{-1},k∈Z$ </p>
<p>  在模 $M$ 的意义下，方程组只有一个解：<br>                                                                               $$x=(\sum^{n}_{i=1}a_iM_iM_i^{-1}) \ mod \ M$$</p>
<p>即：<br>                                                                                  $$x=(\sum^{n}_{i=1}a_i \frac{M}{m_i} (\frac{M}{m_i})^{-1}) \ mod \ M$$</p>
</blockquote>
<p>思路：将多个方程组合为一个方程来求解，即将两个线性同余方程合为一个，以此类推。</p>
<p>推导：</p>
<p>首先考虑前两个线性同余方程：<br>                                                                                        $$x≡a_1 \ mod \ m_1$$<br>​                                                                                        $$x≡a_2 \ mod \ m_2$$ </p>
<p>转化为：<br>                                                                                        $$x=m_1⋅k_1+a_1$$<br>                                                                                        $$x=m_2⋅k_2+a_2$$ </p>
<p>将这两个方程合并移项，可得：<br>                                                                                        $$m_1⋅k_1−m_2⋅k_2=a_2−a_1$$</p>
<p> 即：<br>                                                                                        $$m_1⋅k_1+m_2⋅(-k_2)=a_2−a_1$$</p>
<p><strong>这个方程有解必须满足：</strong><br>                                                                                        $$(a_2-a_1)\ % \ d==0$$</p>
<p>若有解，我们可以通过求<strong>线性同余方程的通解</strong>来得出<br>                                                                                        $$k_1=k_1+\frac{m_2}{d} \cdot k \ ,k∈Z$$<br>                                                                                        $$k_2=k_2+\frac{m_1}{d} \cdot k \ , k∈Z$$</p>
<p>将 $k_1$ 带回 $x=m_1 \cdot k_1 +a_1$ 得：<br>                                                                                        $$x=k_1 \cdot m_1 +a_1$$<br>                                                                                        $$x=(k_1+k \cdot \frac{m_2}{d}) \cdot m_1 + a_1$$</p>
<p>展开：<br>                                                                                        $$x=\frac{m_1m_2}{d} \cdot k+k_1m_1+a_1$$</p>
<p>$\frac{m_1m_2}{d}$ 为 $m_1$ 和 $m_2$  的最小公倍数，即：<br>                                                                                        $$x=[m_1,m_2] \cdot k+k_1m_1+a_1 \ ①$$</p>
<p>可以发现上面的方程与这方程相类似<br>                                                                                        $$x=m⋅k+a$$</p>
<p>对比发现：<br>                                                                                        $$m=[m_1,m_2]$$<br>                                                                                        $$a=k_1m_1+a_1$$</p>
<p>将得到的方程①与下一个同余方程合并，直到最后只剩一个方程时：$x=m \cdot k+a$</p>
<p>即求：<br>                                                                                        $$x \ mod \ m ≡ a$$</p>
<p>即求：<br>                                                                                        $$x=a \ mod \ m$$</p>
<p>最后直接用合并后方程的 $a$ 和 $m$ 求一个最小正整数解即可： $(a % m +m )%m$ </p>
<p>思路就是按照推导过程去实现</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/206/">AcWing 204. 表达整数的奇怪方式</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LL n, a1, a2, k1, k2, m1, m2;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; m1 &gt;&gt; a1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m2 &gt;&gt; a2;</span><br><span class="line">    LL d = <span class="built_in">exgcd</span>(m1, -m2, k1, k2); <span class="comment">// 求得 k1*m1 + k2*(-m2) = d</span></span><br><span class="line">    <span class="keyword">if</span>((a2 - a1) % d) <span class="comment">// 不能整除则无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  求出的是 k1*m1 + k2*m2 = d ，我们需要求的是右边是 a2-a1的值</span></span><br><span class="line"><span class="comment">        因为 d 与 a2-a1 是倍数，所以两边翻(a2-a1)/d倍即可，</span></span><br><span class="line"><span class="comment">        k2不需要翻倍的原因是，不需要用到</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    k1 *= (a2 - a1) / d; <span class="comment">//翻若干倍</span></span><br><span class="line">    LL t = m2 / d; <span class="comment">// k1的通解：k1=k1+m2/d*k ，k∈Z</span></span><br><span class="line">    k1 = (k1 % t + t) % t; <span class="comment">// 将k1变成最小的正整数解</span></span><br><span class="line"></span><br><span class="line">    a1+= k1 * m1; <span class="comment">// a=k1*m1+a1 得先求了a1才能求m1,不然m1值变了</span></span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">abs</span>(m1 / d * m2); <span class="comment">// m=[m1,m2] 最小公倍数数，有可能是负的，这里求一个正的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (a1 % m1 + m1) % m1 &lt;&lt; endl; <span class="comment">//结果就是x = a mod m ，但这里求一个最小正整数解</span></span><br></pre></td></tr></table></figure>





<h1 id="高斯消元解线性方程"><a href="#高斯消元解线性方程" class="headerlink" title="高斯消元解线性方程"></a>高斯消元解线性方程</h1><p>思路：</p>
<ul>
<li>枚举每一列 $c$ <ol>
<li>  找到绝对值最大的一行</li>
<li>  将该行换到最上面</li>
<li>  （倒着算）将该行该列的这个数变成 1</li>
<li>  （从上往下）将下面所有行的第 $c$ 列消成 0</li>
</ol>
</li>
<li>  判断是否有解 或 为无穷解</li>
<li>（从下往上）将上面所有行的第 $c$ 列消成 0<ul>
<li>枚举每一列<ul>
<li>  枚举每一行（倒着算）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h1><p>红线代表曼哈顿距离，绿色代表<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB">欧氏距离</a>，也就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB">直线距离</a>，而蓝色和黄色代表等价的曼哈顿距离。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF">曼哈顿</a>距离——两点在南北方向上的距离加上在东西方向上的距离，即 $d(i,j)=|x_i-x_j|+|y_i-y_j|$ 。曼哈顿距离又称为出租车距离。</p>
<img src="/2021/12/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/曼哈顿距离.png" alt="曼哈顿距离" style="zoom: 67%;">

<p>曼哈顿距离包括终点本身</p>
<p><strong>都是整数</strong></p>
<h1 id="欧几里得距离"><a href="#欧几里得距离" class="headerlink" title="欧几里得距离"></a>欧几里得距离</h1><p>两点之间的距离，也称<strong>欧氏距离</strong></p>
<p>这个就是高中二维和三维坐标系所学的</p>
<p><strong>有浮点数</strong></p>
<p>二维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$$ </p>
<p>三维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}$$ </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/21/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/21/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/" itemprop="url">二分图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-21T16:58:03+08:00">
                2021-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><img src="/2021/12/21/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/二分图例子.png" alt="二分图例子" style="zoom:67%;">
<img src="/2021/12/21/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/二分图.png" alt="二分图" style="zoom:67%;">

<h1 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h1><p>时间复杂度是 $O(n+m)$ ， $n$ 表示点数， $m$ 表示边数</p>
<p>思路：</p>
<ul>
<li>初始化各点为未染色</li>
<li>枚举每个点<ul>
<li>if 该点 a 未被染色<ul>
<li>进行染色并判断是否发生矛盾<br>而这里是采用递归染色， dfs 的思路是：</li>
</ul>
</li>
</ul>
</li>
<li>先将当前结点 $u$ 染色</li>
<li>遍历点 $u$ 的所有邻接点<ul>
<li>if 该点未染色<ul>
<li>dfs 染色，且判断他的邻接点及其后的点染色是否发生矛盾</li>
</ul>
</li>
<li>else if 如果该点已经被染色了，那判断该点是否与点 $u$ 颜色相同</li>
</ul>
</li>
</ul>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/862/">AcWing 860. 染色法判定二分图</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 将点 u 染成c号色，并将点 u 下的点按二分图规则染色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">//染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>) <span class="comment">// 点j未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="comment">// 如果在此过程中有一个地方发生矛盾，则肯定不是二分图</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果该点已经被染色了，且与点u颜色相同，那肯定有矛盾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断邻接表是否为二分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color); <span class="comment">//初始化染色数组</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 枚举每个点，防止图不是连通图</span></span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>) <span class="comment">// 如果未被染色，则深度优先染色</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>)) <span class="comment">// 进行染色且返回是否染色没发生矛盾</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>时间复杂度是 $O(nm)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/863/">AcWing 861. 二分图的最大匹配</a></p>
<p>按照 y 总的思路，将左半部集合看成是男生，右半部看成女生，逐一给他们牵红线，如果遇到喜欢同一个女生，则看看上家有没有其他备胎可选</p>
<p>核心还是递归</p>
<p>思路：</p>
<ul>
<li>初始化所有女孩的配对都为 0</li>
<li>遍历所有男生<ul>
<li>重置每个女生配对预选人</li>
<li>（递归）寻找该男生的配对，并判断能否找到心仪对象<br>递归配对思路：</li>
</ul>
</li>
<li>遍历该男生心仪女孩<ul>
<li>如果未被遍历，则设置为已遍历<ul>
<li>如果如果女孩j没有男朋友，或者她原来的男朋友能够匹配其它喜欢的女孩。配对成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7y35ngyr5g311v0j67jy.gif" alt="匈牙利算法"></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合（左集合）中的点数，n2表示第二个集合（右集合）中的点数</span></span><br><span class="line">                <span class="comment">// n1的点作为槽，n2的点作为邻接点</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];    <span class="comment">// 存储右集合中的每个点当前匹配的左集合中的点是哪个</span></span><br><span class="line">                 <span class="comment">// match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示模拟匹配时，右集合中的每个点是否已经被遍历过</span></span><br><span class="line">                <span class="comment">// st[]数组我称为临时预定数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找点x的匹配值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 如果在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果该女生未被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果女孩j没有男友，或者她原来的男友能够预定其它喜欢的女孩。配对成功</span></span><br><span class="line">            <span class="comment">// 这里 match[j]就是女生 j 的男友</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) <span class="comment">// 如果他不在已确认的点中 或 这个点能找到下家</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己中意的全部都被预定了。配对失败。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历所有男生</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ ) <span class="comment">// 遍历左集合的每一个点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匈牙利算法的优势：</p>
<p>匈牙利算法中，一个有伴侣的人，无论男女，<strong>不会重新变成单身狗</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/20/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/20/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" itemprop="url">最小生成树汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-20T11:58:03+08:00">
                2021-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><img src="/2021/12/20/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/最小生成树.png" alt="最小生成树" style="zoom:67%;">



<h2 id="动画思路"><a href="#动画思路" class="headerlink" title="动画思路"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eb41177d1/">动画思路</a></h2><h1 id="朴素Prim算法"><a href="#朴素Prim算法" class="headerlink" title="朴素Prim算法"></a>朴素Prim算法</h1><p>稠密图</p>
<p>时间复杂度是 $O(n^2+m)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p><strong>思路</strong>（与dijkstra算法相似）：</p>
<ul>
<li>  所有点到连通块（集合）的距离初始化为正无穷，即所有点初始时都不在连通块中</li>
<li>  选取任意一个点作为连通块中的一个点</li>
<li>迭代n次<ul>
<li>  每次找到 不在集合中 距离最小 的点 t（连通块是当前生成树）</li>
<li>  用 t 更新其他点的距离到连通块的距离</li>
<li>  把 t 加到集合中</li>
</ul>
</li>
</ul>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];	<span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];	<span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];		<span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 迭代n次（加入n个点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找与i直接联通的边最小值的点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 这里j下标对应g[][]</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">// 这里一定会更新t的</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">//如果最短的距离是INF那说明无法生成最小树了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t]; <span class="comment">// 先累加，因为如果先更新点t到其他点的距离，遇上负环的话，会把自己更新的更小</span></span><br><span class="line">        <span class="comment">// 把点加到连通块</span></span><br><span class="line">        st[t] = <span class="literal">true</span>; </span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 更新点t到其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>稀疏图</p>
<p>时间复杂度是 $O(mlogm) $， $n$ 表示点数，$m$ 表示边数</p>
<p><strong>思路</strong>（类似并查集）：</p>
<ul>
<li>  将所有边按权重从小到大排序</li>
<li>枚举每条边a,b 权重c<ul>
<li>if a,b不连通<ul>
<li>  将这条边加入连通块（集合）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>具体可以参考动画思路，先按边的权重排序，如果点 a,b 不在集合中，则将这条边加入集合中，即将 点 a 的祖宗节点指向 b 即可（a 和 b 掉转也行），这样就能将 a 与 b 归为一个集合，重复上诉操作，而这样是不会有环的，因为每次只会加入一个点，而且已经加入的点是不会再更新的</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> fa[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="comment">// 重载 小于号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;e1)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e1.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作, 查找x的祖宗结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) fa[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 归到一个集合中</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/20/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/20/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/" itemprop="url">前缀和 和 差分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-20T00:13:17+08:00">
                2021-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>求<code>[l, r]</code>之和 $\sum_{i=l}^{r}{a_i}=a_l+a_{l+1}+…+a_r$</p>
<p><strong>结论：</strong>$$S_{lr} = S_r - S_{l-1}$$</p>
<p>推导：</p>
<blockquote>
<p>  $$S_r=a_1+a_2+…+a_{l-1}+a_l+…+a_r$$</p>
<p>  $$S_{l-1}=a_1+a_2+…+a_{l-1}$$</p>
<p>  即：</p>
<p>  $$S = S_r - S_{l-1}$$</p>
<p>  $$S = a_l+a_{l+1}+…+a_r$$</p>
</blockquote>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>求<code>(x1, y1) ~ (x2, y2)</code>前缀和</p>
<blockquote>
<p>  初始化的二维前缀和：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">       s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>结论：</strong>$$S=S-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}$$</p>
<p>即：<code>s = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p>
<img src="/2021/12/20/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/二维子矩阵前缀和.png" alt="二维子矩阵前缀和" style="zoom:70%;">



<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分数组前n项和即为前缀和，其实就是前缀和的逆运算</p>
<h2 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h2><p><strong>给区间$[l, r]$中的每个数加上c：</strong>（例题：ACWing 797.差分）</p>
<p><strong>结论：</strong><code>b[l] += c, b[r + 1] -= c</code></p>
<p>只要<code>b[l]</code>加上 c，则 <code>l</code> 后面的前 n 项和都加上 c 了，所以要在 <code>b[r + 1]</code> 减上 c ，才能持 0</p>
<p>设 $a_n$ 为 $b_n$ 的前n项和，则</p>
<p>既然差分是前缀和的逆运算，那么可以用上诉结论来逆运算出<code>b[]</code> </p>
<p>即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[i]+=c;</span><br><span class="line">    b[i+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出时，只需要对<code>b[]</code> 用一维前缀和公式即可</p>
<h2 id="二维差分数组"><a href="#二维差分数组" class="headerlink" title="二维差分数组"></a>二维差分数组</h2><p>给以<code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵中的所有元素加上c：<br><strong>结论：</strong><code>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</code></p>
<p>设 <code>a[][]</code> 为 <code>b[][]</code> 的前缀和</p>
<img src="/2021/12/20/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/二维差分矩阵.png" alt="二维差分矩阵" style="zoom:67%;">

<p>即为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化可以为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br></pre></td></tr></table></figure>

<p>输出结果，同样是二维前缀和</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" itemprop="url">拓扑排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-17T00:35:03+08:00">
                2021-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>时间复杂度 $O(n+m)$ ， $n$ 表示点数，$m$ 表示边数<br>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">AcWing 848. 有向图的拓扑序列</a><br>思路：（宽搜 + 删点）</p>
<ul>
<li>（队列初始化）先让所有入度为 0 的点入队</li>
<li>while(队列非空)<ul>
<li>获取队头并弹出</li>
<li>更新该点的邻接点的入度<ul>
<li>将入度为 0 的点入队</li>
</ul>
</li>
</ul>
</li>
<li>如果所有点都入过队了，说明存在拓扑序列；否则不存在拓扑序列。</li>
</ul>
<p>最好用模拟队列实现，因为方便</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[N];<span class="comment">// 结点的入度</span></span><br><span class="line"><span class="keyword">int</span> que[N]; <span class="comment">// 模拟队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽搜思想 + 删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fr = <span class="number">0</span>, re = <span class="number">-1</span>; <span class="comment">// 还没加进去元素时，队尾设为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            que[++re] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= re)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = que[fr++]; <span class="comment">// 获取队头并弹出</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 更新删除 t 结点后所有点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                que[++re] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> re == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8E%E5%9B%BE%E9%81%8D%E5%8E%86/%E6%A0%91%E4%B8%8E%E5%9B%BE%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8E%E5%9B%BE%E9%81%8D%E5%8E%86/%E6%A0%91%E4%B8%8E%E5%9B%BE%E9%81%8D%E5%8E%86/" itemprop="url">树与图遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-17T00:27:03+08:00">
                2021-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="树与图遍历"><a href="#树与图遍历" class="headerlink" title="树与图遍历"></a>树与图遍历</h1><p>时间复杂度 $O(n+m)$ ， $n$ 表示点数，$m$ 表示边数</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/848/">AcWing 846. 树的重心</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>; <span class="comment">// vis[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/849/">AcWing 847. 图中点的层次</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" itemprop="url">最短路径汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-17T00:00:03+08:00">
                2021-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最短路径汇总"><a href="#最短路径汇总" class="headerlink" title="最短路径汇总"></a>最短路径汇总</h1><img src="/2021/12/17/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/最短路径.png" alt="最短路径" style="zoom: 50%;">

<h1 id="遍历点"><a href="#遍历点" class="headerlink" title="遍历点"></a>遍历点</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>基本思路：（基于贪心）</p>
<ul>
<li>  先初始化所有点到根结点的距离为正无穷，每个点是否确认为最短路径的点初始化为 $false$</li>
<li>  将1号点到根结点的距离初始化为0，默认从1号点到n号点</li>
<li>迭代 $n-1$ 次（或 用堆的大小判断循环结束）<ul>
<li>  寻找当前 <code>dist[]</code> 中路径最小值，并保存其下标 <code>t</code></li>
<li>  用 <code>t</code> 更新其他点的距离</li>
<li>  将点 <code>t</code> 设为最短路径上的点<h2 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h2></li>
</ul>
</li>
</ul>
<p>时间复杂是 $O(n^2+m)$， $n$ 表示点数，$m$ 表示边数</p>
<p><strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zz4y1m7Nq?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">动画算法思路</a></strong></p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/851/">AcWing 849. Dijkstra求最短路 I</a></p>
<p>这里只需迭代 $n-1$ 次是因为要加入所有点，而加入 n 个点需要加入 $n-1$ 条边，其实迭代到最后只有一个点的时候，最后的点是无法再更新其他点到这个点的最短距离了，而每次更新距离数组的时候，都是存最小值，所以最后的 <code>dist[n]</code> 也必是最短的。当然，你迭代 n 次也没错</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自环不影响，重环的话取最短的即可</span></span><br><span class="line"><span class="comment">// 贪心 + 宽搜</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// dist[]从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 循环n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="comment">// 寻找当前dist[]中路径最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// dist[]从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">// 没有被加入 且 t==-1 或 这次路径比上次最小路径小</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// dist[]从1开始</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 从1号点到不了n号点</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h2><p>时间复杂度 $O(mlogn)$， $n$ 表示点数，$m$ 表示边数</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/852/">AcWing 850. Dijkstra求最短路 II</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span> <span class="comment">// 优先队列头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span> <span class="comment">// greater&lt;&gt;头文件</span></span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII; <span class="comment">//first是路径长度，second是结点编号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪心（核心） + 宽搜 + 堆优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">// 小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取路径最小的点</span></span><br><span class="line">        PII t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>; <span class="comment">// 如果这个点已经确定为最短路径的点，则不执行以下操作了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>; <span class="comment">//设置该点为已确定最短路径</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 同样的，更新dist[]中每个点的最短路径，只不过这里是放入小根堆，小根堆会维护升序序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 从1号点到不了n号点</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="遍历边"><a href="#遍历边" class="headerlink" title="遍历边"></a>遍历边</h1><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman_Ford算法"></a>Bellman_Ford算法</h2><p>时间复杂度 $O(nm)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/855/">AcWing 853. 有边数限制的最短路</a></p>
<p>思路：（基于离散数学）</p>
<ul>
<li>初始化所有点的距离到 1 号点的距离为正无穷，并设置 1 号点距离为 0</li>
<li>经过 1～n 条边（有边数限制 k 的话，替换成 k ）<ul>
<li>将上一轮各点的距离都备份一下</li>
<li>更新所有点到 1 号点的距离（松弛不等式）</li>
</ul>
</li>
</ul>
<p>⚠️注意更新所有点的距离时，每个点的距离都有可能被更新，所以判断返回值时需要以 <code>dist[n] &gt; INF / 2</code> 判断是否无最短路径<br>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;      <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="keyword">int</span> backup[N]; <span class="comment">// 存储1到x的最短距离的上一个状态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125; e[N]; <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回INF</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 只有n个点，如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 经过不超过m条边，即最多经过m-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist); <span class="comment">// 将dist[]值复制一份到backup[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[j].a, b = e[j].b, w = e[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w); <span class="comment">// 松弛不等式（离散数学专业术语罢了）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否存在1~n的最短距离，这里要大于INF/2，因为有可能是第n号点加上了负权边</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; INF / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong>如果题目限制边数为 $k$ ，则 <code>backup[]</code> 一定得有，因为需要获取上一个状态的1到各点最短路径，即 经过 $k$ 条边时的最短路径 需要 经过 $k-1$ 条边时的1到各点最短路径 来确定</p>
<p>单纯只求最短路径的话，可以不需要 <code>backup[]</code> 数组，即修改 <code>for</code> 循环为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = e[j].a, b = e[j].b, w = e[j].w;</span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], dist[a] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其他都不用变，当然啦，一般题目<strong>有边数限制</strong>才用 $bellman$ 算法，否则其他算法（例如：SPFA算法）效率都比它更好</p>
</blockquote>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>队列优化的 Bellman-Ford 算法</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/853/">AcWing 851. spfa求最短路</a></p>
<p>时间复杂度  平均情况下 $O(m)$ ，最坏情况下 $O(nm)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p>思路：（基于离散数学）</p>
<ul>
<li><p>同样的，初始化所有点到 1 号点距离为正无穷，且 1 号点距离为 0，并将 1 号点入队，将 1 号点设置为已在队列的标志</p>
</li>
<li><p>while(队列是否为空)</p>
<ul>
<li>取出队头 t ，并弹出</li>
<li>设置点 t 不在队列中</li>
<li>用点 t 更新各点到 1 号点到距离<ul>
<li>如果有比当前距离更短的（松弛不等式）<ul>
<li>更新且入队</li>
<li>设置该点在队列标志</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;	<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];	<span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];		<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bellman_ford宽搜改良（队列优化），遍历点的出边</span></span><br><span class="line"><span class="comment">// 基本思路大概是：用队列存已经遍历到的点，然后拿出来，宽搜其出边是否比dist[]中的小，小的话更新，且如果该点不在队列中就入队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回INF</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 从1出发</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 从1出发</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 更新dist[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) <span class="comment">// 遍历t结点中所有出边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) <span class="comment">// 和dijkstra一样取最短（松弛不等式）</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>注意</strong>这个SPFA算法是不能适用于<strong>有负环</strong>的题目的</p>
</blockquote>
<p><strong>SPFA怕判断图中是否存在负环</strong></p>
<p>时间复杂度是 $O(nm)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/854/">AcWing 852. spfa判断负环</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;	<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];	<span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];	<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// dist[]不用初始化，因为不需要算出最短距离，且判断是否存在负环不需要用到里面的准确数据</span></span><br><span class="line">    <span class="comment">// 一般存在负环，他就死循环了，一直到 cnt[j] &gt;= n才出来，所以复杂度也相当高，和bellman算法一样</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在负环</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>; <span class="comment">// 从结点t出发到其出边的另一头顶点的步数就是加上1</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在负环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  一般求是否存在负环问题，都不会用SPFA算法，因为相比 bellman 写法，复杂度一样，那肯定选代码量小一点的 bellman 算法呐</p>
</blockquote>
<h1 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h1><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>基于DP思想，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q4411M7r9?spm_id_from=333.1007.top_right_bar_window_history.content.click">算法思路</a>，空降7：45</p>
<p>时间复杂度是 $O(n^3)$ ， $n$ 表示点数</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/856/">AcWing 854. Floyd求最短路</a></p>
<p>思路：</p>
<ul>
<li>基于 DP</li>
</ul>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> <span class="comment">// 采用了滚动数组</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">// d[k,i,j]是i在1~k中到j的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


























          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/14/%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/14/%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%B0%8F%E6%8A%80%E5%B7%A7/" itemprop="url">小技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-14T22:30:17+08:00">
                2021-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="一维转二维"><a href="#一维转二维" class="headerlink" title="一维转二维"></a>一维转二维</h2><p><code>s[]:</code> <code>1 2 3 4 5 6 7 c 8 9 10 11</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s[4][3]:</span><br><span class="line">1  2  3 </span><br><span class="line">4  5  6</span><br><span class="line">7  c  8</span><br><span class="line">9  10 11</span><br></pre></td></tr></table></figure>

<p>若我们求 $c$ 的坐标 $(x,y)$ ，我们要先知道 $c$ 在一维中的是第 $k$ 个元素，然后可以用一次函数的思想 $y=ax+b$ ，因为一次函数是二维的嘛，而这里的 $a$ 可以看作是 <code>s[][]</code> 一层中<strong>共有</strong>  $a$ 个元素，而 $b$ 可以看作是 <code>s[][]</code> 这一层中第 $b$ 个元素</p>
<blockquote>
<p>  那x —&gt; <code>x = k / a</code><br>  而y —&gt; <code>y = k % a</code><br>  如上的例子：<br>  <code>k = 7, a = 3</code><br>  <code>x = 7 / 3 = 2, y = 7 % 3 = 1</code><br>  则 <code>s[x][y]</code> 就是 $c$ 的坐标</p>
<p>  <strong>一维数组的坐标用二维坐标表示</strong>就是用一次函数的思想：<code>s[a*x+y]</code><br>  即：<code>s[3 * 2 + 1] = s[7]</code></p>
</blockquote>
<img src="/2021/12/14/%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%B0%8F%E6%8A%80%E5%B7%A7/一次函数.png" alt="一次函数" style="zoom:61%;">



<h2 id="二维转一维"><a href="#二维转一维" class="headerlink" title="二维转一维"></a>二维转一维</h2><p>同样也需要用一次函数来转换 $y=ax+b$ ，同样的，其实就是上面的逆运算，$a$ 同样是一层中有多少个元素， $b$ 则是本层中第 $b$ 个元素</p>
<p><code>s[]:</code> <code>1 2 3 4 5 6 7 c 8 9 10 11</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s[4][3]:</span><br><span class="line">1  2  3 </span><br><span class="line">4  5  6</span><br><span class="line">7  c  8</span><br><span class="line">9  10 11</span><br></pre></td></tr></table></figure>

<p><code>s[x][y]</code> ，求 x 和 y ：已知 $c$ 在一维数组中的下标 <code>k = 7</code></p>
<p><code>x = k / a</code><br><code>y = k % a</code></p>
<blockquote>
<p>  <code>x = 7 / 3 = 2</code></p>
<p>  <code>y = 7 % 3 = 1</code></p>
<p>  <code>s[2][1] = c</code></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/12/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/12/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" itemprop="url">区间合并</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-12T16:01:17+08:00">
                2021-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/805/">AcWing 803. 区间合并</a></p>
<p>给定 $n$ 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。</p>
<p>注意如果在端点处相交，也算有交集。</p>
<p>输出合并完成后的区间个数。</p>
<p>例如：$[1,3]$ 和 $[2,6]$ 可以合并为一个区间 $[1,6]$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    l=<span class="number">-2e9</span>,r=<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;a[i].first) <span class="comment">// 只需判断扩张区间是不是断了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;); <span class="comment">// 第一次的时候，肯定是不执行的，所以这个是存入上一次的合并区间</span></span><br><span class="line">            l=a[i].first,r=a[i].second; <span class="comment">// 那合并区间断了，肯定要重新定左端点和右端点啊</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r=<span class="built_in">max</span>(r,a[i].second); <span class="comment">// 没断的话，取右端点最大值就好了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;); <span class="comment">//因为是存入上一次的合并区间，所以这次的还没存</span></span><br><span class="line">    a=res; <span class="comment">// 结果数组赋值回去罢了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/10/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/m.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/10/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/" itemprop="url">常见模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-10T21:31:17+08:00">
                2021-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>模板题： <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/832/">AcWing 830. 单调栈</a></p>
<p>模型：找出每个数左边离它最近的比它大/小的数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; <span class="built_in">check</span>(st[top - <span class="number">1</span>], i)) top -- ;</span><br><span class="line">    st[ ++ top] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>check()</code> 就是判断栈顶元素与其他元素之间的关系，与题目有关</p>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/156/">AcWing 154. 滑动窗口</a></p>
<p>模型：找出滑动窗口中的最大值/最小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">-1</span>; <span class="comment">// 队头、队尾指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear &amp;&amp; <span class="built_in">check_out</span>(q[front])) front ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear &amp;&amp; <span class="built_in">check</span>(q[rear], i)) rear -- ;</span><br><span class="line">    q[ ++ rear] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[]为需要找的数组，k为滑动窗口大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front &lt;= rear &amp;&amp; i - k + <span class="number">1</span> &gt; q[front]) <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">        front++;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear &amp;&amp; a[i] &lt;= a[q[rear]])</span><br><span class="line">        rear--; <span class="comment">// 清除当前队列中的元素</span></span><br><span class="line">    que[++rear] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; a[q[front]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当找最小值时，队列中队头元素是最小的，依次往后排都是比前一个大的元素，当当前元素<code>a[i]&lt;=</code>队头的最小元素时，循环判断队列中的元素是否有小于<code>a[i]</code>，没有则继续从后向前判断，并将队头出队</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/home/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/6/">6</a><a class="extend next" rel="next" href="/home/page/2/">&gt;</a>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/m.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DueGin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DueGin</span>

  
</div>







<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
