<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT, technology blog, open source blog, C++ blog" />










<meta property="og:type" content="website">
<meta property="og:title" content="DueGin">
<meta property="og:url" content="https://duegin.github.io/page/3/index.html">
<meta property="og:site_name" content="DueGin">
<meta property="og:locale">
<meta property="article:author" content="DueGin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://duegin.github.io/page/3/"/>





  <title>DueGin</title>
  








<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DueGin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2022/03/22/MySQL/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/22/MySQL/MySQL/" itemprop="url">MySQL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-22T21:39:17+08:00">
                2022-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="yu-yi">语义</h1>
<p>括号<code>[]</code>表示可选</p>
<h1 id="my-sql-8-0-an-zhuang">MySQL 8.0安装</h1>
<h3 id="yi-zai-ubuntu-shang-an-zhuang-my-sql-8-0">一、在Ubuntu上安装MySQL 8.0</h3>
<p>先更新一下<code>apt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>通过<code>apt</code>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>
<p>验证 MySQL 服务器是否正在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysql</span><br></pre></td></tr></table></figure>
<p>若显示以下内容，则应该是已经启动并正在运行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql.service - MySQL Community Server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Tue 2020-04-28 20:59:52 UTC; 10min ago</span><br><span class="line">   Main PID: 8617 (mysqld)</span><br><span class="line">     Status: &quot;Server is operational&quot;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<p>若开启的话，去第二部分，<strong>没有的话</strong>，走一下下面流程：</p>
<blockquote>
<ol>
<li><code>su root </code>且输入密码切换成超级用户</li>
<li><code>cd /var</code>进入此文件夹，输入<code>service mysql start</code>开启<code>mysql</code>服务</li>
<li><code>netstat -na</code> 查看3306端口是否开启，没有则开启一下</li>
</ol>
</blockquote>
<h3 id="er-bao-hu-jia-gu-my-sql">二、保护加固MySQL</h3>
<p>MySQL 安装文件附带了一个名为<code>mysql_secure_installation</code>的脚本，它允许你很容易地提高数据库服务器的安全性。</p>
<p>不带参数运行这个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>你将会被要求配置<code>VALIDATE PASSWORD PLUGIN</code>，它被用来测试 MySQL 用户密码的强度，并且提高安全性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Connecting to MySQL using a blank password.</span><br><span class="line"></span><br><span class="line">VALIDATE PASSWORD COMPONENT can be used to test passwords</span><br><span class="line">and improve security. It checks the strength of password</span><br><span class="line">and allows the users to set only those passwords which are</span><br><span class="line">secure enough. Would you like to setup VALIDATE PASSWORD component?</span><br><span class="line"></span><br><span class="line">Press y|Y for Yes, any other key for No: y</span><br></pre></td></tr></table></figure>
<p>有三个级别的密码验证策略，低级，中级，高级。如果你想设置验证密码插件，按<code>y</code>或者其他任何按键，移动到下一个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are three levels of password validation policy:</span><br><span class="line"></span><br><span class="line">LOW    Length &gt;= 8</span><br><span class="line">MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</span><br><span class="line">STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  file</span><br><span class="line"></span><br><span class="line">Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 2</span><br></pre></td></tr></table></figure>
<p>下一步被提示时，你将被要求为 MySQL root 用户设置一个密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Please set the password for root here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">New password: </span><br><span class="line"></span><br><span class="line">Re-enter new password: </span><br></pre></td></tr></table></figure>
<p>如果你设置了验证密码插件，这个脚本将会显示你的新密码强度。输入<code>y</code>确认密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Estimated strength of the password: 50 </span><br><span class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</span><br></pre></td></tr></table></figure>
<p>下一步，是否移除匿名用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br></pre></td></tr></table></figure>
<p>下一步，是否禁止 root 用户远程连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#x27;localhost&#x27;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y</span><br></pre></td></tr></table></figure>
<p>下一步，是否移除测试数据库，这个看个人吧，我一般保留</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">By default, MySQL comes with a database named &#x27;test&#x27; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : n</span><br></pre></td></tr></table></figure>
<p>下一步，是否现在重新加载特权表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</span><br></pre></td></tr></table></figure>
<h3 id="san-yi-root-yong-hu-shen-fen-deng-lu-my-sql">三、以 root 用户身份登录MySQL</h3>
<p>在MySQL 8.0上，root 用户默认通过<code>auth_socket</code>插件授权。</p>
<p><code>auth_socket</code>插件通过 Unix socket 文件来验证所有连接到<code>localhost</code>的用户。这意味着你不能通过提供密码，验证为 root。</p>
<p>以 root 用户身份登录 MySQL服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>输入密码后，看到以下信息即登陆成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 16</span><br><span class="line">Server version: 8.0.28-0ubuntu0.20.04.3 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2022, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">(root@localhost)[(none)]&gt;</span><br></pre></td></tr></table></figure>
<p>执行这句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select host,user,plugin,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>
<p>修改权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;</span><br></pre></td></tr></table></figure>
<p>刷新配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p><em><strong>OK</strong></em></p>
<p>至于查看mysql的状态还是显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@b6beb613ab1f:/var# sudo systemctl status mysql</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure>
<p>这个我也不知道，总之就是MySQL能用</p>
<h1 id="dao-chu-shu-ju">导出数据</h1>
<p>导出为 <code>.txt</code> 和  <code>.sql</code> 都一样，因为里面的内容都一样的</p>
<h2 id="dao-chu-mou-ge-shu-ju-ku">导出某个数据库</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p 某个数据库 &gt; database_dump.sql</span><br></pre></td></tr></table></figure>
<p>导出全部数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p --all-databases &gt; database_dump.sql</span><br></pre></td></tr></table></figure>
<h2 id="dao-chu-mou-ge-shu-ju-biao">导出某个数据表</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p 数据库名 某个数据表 &gt; database_dump.sql</span><br></pre></td></tr></table></figure>
<h1 id="dao-ru-shu-ju">导入数据</h1>
<h2 id="dao-ru-mou-ge-shu-ju-ku">导入某个数据库</h2>
<ul>
<li>直接导入（没试过能行）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码 &lt; 要导入的数据库数据(runoob.sql)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用source导入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database abc;      # 创建数据库</span><br><span class="line">mysql&gt; use abc;                  # 使用已创建的数据库 </span><br><span class="line">mysql&gt; set names utf8;           # 设置编码</span><br><span class="line">mysql&gt; source /home/abc/abc.txt  # 导入备份数据库</span><br></pre></td></tr></table></figure>
<h1 id="code-constraint-code"><code>constraint</code></h1>
<p>起名</p>
<h1 id="yue-shu">约束</h1>
<p>SQL 约束用于规定表中的数据规则。</p>
<p>如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p>对表中的数据进行限定，保证数据的正确性，有效性和完整性。</p>
<p><strong>分类：</strong></p>
<ul>
<li>主键：<code>primary key</code></li>
<li>非空约束：<code>not null</code></li>
<li>唯一约束：<code>unique</code></li>
<li>外键约束：<code>foreign key</code></li>
<li><code>check</code></li>
</ul>
<h2 id="fei-kong-yue-shu">非空约束</h2>
<p><code>not null</code>，值不能为空</p>
<ul>
<li><strong>创建表时添加非空约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建完表后，添加非空约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stu modify name VARCHAR(20) not null;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除非空约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>
<h2 id="wei-yi-yue-shu">唯一约束</h2>
<p><code>unique</code>，值不能重复</p>
<ul>
<li><strong>创建表时添加唯一约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE stu(</span><br><span class="line">    id INT;</span><br><span class="line">    phone_number VARCHAR(20) UNIQUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>**注意：**MySQL 中，唯一约束限定的列的值可以有多个 <code>null</code>。</p>
<p>给唯一约束起名 <code>uq_cname</code></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table course(</span><br><span class="line">    课号 char(4) not null,</span><br><span class="line">    课名 char(20),</span><br><span class="line">    学分 int,</span><br><span class="line">    constraint uq_cname unique(课名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建表完后，添加唯一约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除唯一约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stu drop index phone_number;</span><br></pre></td></tr></table></figure>
<h2 id="zhu-jian-yue-shu">主键约束</h2>
<p><code>primary key</code></p>
<ul>
<li>非空且唯一</li>
<li>一张表只能有一个字段为主键</li>
<li>主键就是表中记录的唯一标识</li>
</ul>
<h3 id="chuang-jian-biao-shi">创建表时</h3>
<ul>
<li><strong>添加主键约束</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu( </span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加组合主键</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table stu( </span><br><span class="line">    id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    primary key(id, name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="code-auto-increment-code-zi-dong-zeng-chang"><code>auto_increment</code> 自动增长</h4>
<p>对某个主键声明，则可以使其在添加数据的时候，自增</p>
<ul>
<li>
<p>建表时，添加主键约束，并且完成主键自动增长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">#自动增长会根据当前列的最后一行的值往后增加。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建表完后，在添加自动增长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stu modify id int auto_increment;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除自动增长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table stu modify id INT;</span><br><span class="line">#这样只会删除自动增长，主键删不掉。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>有自增主键是插入数据：</strong></p>
</li>
</ul>
<blockquote>
<p>如</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu (</span><br><span class="line">    id int not null primary key auto_increment,</span><br><span class="line">    name varchar(8)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>三种方法：</p>
<ul>
<li>
<p><strong>将该自增主键设置为null</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu values(null, &quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>将该自增主键设置为0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu values(0, &quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>插入时提前声明属性列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu(name) values(&quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="chuang-jian-biao-wan-hou-tian-jia-zhu-jian">创建表完后，添加主键</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stu modify id int primary key;</span><br></pre></td></tr></table></figure>
<h3 id="shan-chu-zhu-jian">删除主键</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stu drop primary key;</span><br></pre></td></tr></table></figure>
<h2 id="wai-jian-yue-shu">外键约束</h2>
<p><code>foreign ley</code>，让表与表产生关系，从而保证数据的正确性</p>
<ul>
<li>
<p><strong>在创建表时，可以添加外键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table sc(</span><br><span class="line">    学号 char(4) not null,</span><br><span class="line">    课号 char(4) not null,</span><br><span class="line">    成绩 decimal(5,2) check(成绩 between 0 and 100),</span><br><span class="line">    primary key(学号,课号),</span><br><span class="line">    constraint fk_sno foreign key(学号) references stu(学号)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建表之后，添加外键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key(外键字段名称) references 主表名称(主表列名称);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除外键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名称;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="code-check-code"><code>check</code></h2>
<p>利用 <code>check</code> 可以对数值<strong>设置取值范围</strong></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table sc(</span><br><span class="line">    学号 char(4) not null,</span><br><span class="line">    课号 char(4) not null,</span><br><span class="line">    成绩 decimal(5,2) check(成绩 between 0 and 100), # 0 ≤ 成绩 ≤ 100</span><br><span class="line">    primary key(学号,课号),</span><br><span class="line">    constraint fk_sno foreign key (学号) references stu(学号)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="ji-lian-geng-xin-he-ji-lian-shan-chu">级联更新和级联删除</h1>
<p><code>on delete cascade</code> 级联删除<br>
<code>on update cascade</code> 级联更新</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangwanchao/p/5105562.html">Oracle系列–级联删除和级联更新 - impwang - 博客园 (cnblogs.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-- 班级表</span><br><span class="line">CRATE TABLE TB_CLASS</span><br><span class="line">(</span><br><span class="line">  ID    NUMBER NOT NULL, --班级主键</span><br><span class="line">  NAME  VARCHAR2(50), --班级名称</span><br><span class="line">  CONSTRAINT PK_TB_CLASS PRIMARY KEY (ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE TB_STUDENT</span><br><span class="line">(</span><br><span class="line">  ID        NUMBER NOT NULL,   --学生主键</span><br><span class="line">  NAME      VARCHAR2(50),      --学生姓名</span><br><span class="line">  CLASS_ID  NUMBER,            --学生所属班级，外键</span><br><span class="line"></span><br><span class="line">  --主键约束</span><br><span class="line">  CONSTRAINT PK_TB_STUDENT PRIMARY KEY (ID),</span><br><span class="line"></span><br><span class="line">  --外键约束</span><br><span class="line">  --设置级联删除为NO ACTION</span><br><span class="line">  CONSTRAINT FK_TB_STUDENT_CLASS_ID FOREIGN KEY (CLASS_ID) REFERENCES TB_CLASS (ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加班级数据</span><br><span class="line">INSERT INTO TB_CLASS (ID, NAME) VALUES (1, &#x27;一班&#x27;);</span><br><span class="line">INSERT INTO TB_CLASS (ID, NAME) VALUES (2, &#x27;二班&#x27;);</span><br><span class="line">INSERT INTO TB_CLASS (ID, NAME) VALUES (3, &#x27;三班&#x27;);</span><br><span class="line"></span><br><span class="line">-- 添加学生数据</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (1, &#x27;小明&#x27;, 1);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (2, &#x27;小刚&#x27;, 1);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (3, &#x27;小王&#x27;, 1);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (4, &#x27;二明&#x27;, 2);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (5, &#x27;二刚&#x27;, 2);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (6, &#x27;二王&#x27;, 2);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (7, &#x27;大明&#x27;, 3);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (8, &#x27;大刚&#x27;, 3);</span><br><span class="line">INSERT INTO TB_STUDENT (ID, NAME, CLASS_ID) VALUES (9, &#x27;大王&#x27;, 3);</span><br></pre></td></tr></table></figure>
<h1 id="hong-fa-qi">触发器</h1>
<p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象 ，即表的操作事件触发表上的触发器的执行。</p>
<h2 id="chuang-jian-hong-fa-qi">创建触发器</h2>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create trigger 触发器名字 before|after 触发事件名 on 表名 for each row</span><br><span class="line">begin</span><br><span class="line"> -- 触发器逻辑....</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>触发器名字：</p>
<p>必须在当前数据库中唯一</p>
</li>
<li>
<p>触发事件：</p>
<p><code>insert</code> 或 <code>update</code> 或 <code>delete</code></p>
</li>
<li>
<p><code>before</code> 或 <code>after</code>：</p>
<p>触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发</p>
</li>
</ul>
<p>例如：</p>
<p>当 <code>stu</code> 表新加一条数据后，将添加新数据时的时间加到 <code>test</code> 表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create trigger test_trig after insert on stu for each row</span><br><span class="line">begin</span><br><span class="line">insert into test values(sysdate());</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<h2 id="cha-kan-hong-fa-qi">查看触发器</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show triggers [from 表名|视图|数据库] \G;</span><br></pre></td></tr></table></figure>
<p>在查看</p>
<h2 id="shan-chu-he-xiu-gai-hong-fa-qi">删除和修改触发器</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop trigger [ if exists ] [数据库名] 触发器名</span><br></pre></td></tr></table></figure>
<ul>
<li><code>if exists</code>：避免在没有触发器的情况下删除触发器。</li>
</ul>
<p>删除一个表的同时，也会自动删除该表上的触发器。</p>
<p>如果想要修改触发器，必须先把他删掉，重新创建才行</p>
<h1 id="you-biao">游标</h1>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<p>在 MySQL 中，存储过程或函数中的查询有时会返回多条记录，而使用简单的 SELECT 语句，没有办法得到第一行、下一行或前十行的数据，这时可以使用游标来逐条读取查询结果集中的记录。游标在部分资料中也被称为光标。</p>
<p>关系数据库管理系统实质是面向集合的，在 MySQL 中并没有一种描述表中单一记录的表达形式，除非使用 WHERE 子句来限制只有一条记录被选中。所以有时我们必须借助于游标来进行单条记录的数据处理。</p>
<p>一般通过游标定位到结果集的某一行进行数据修改。</p>
<blockquote>
<p>结果集是符合 SQL 语句的所有记录的集合。</p>
</blockquote>
<h2 id="1-sheng-ming-you-biao">1、声明游标</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare 游标名 cursor for select操作</span><br></pre></td></tr></table></figure>
<p>可以返回一行或多行数据</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare classCursor </span><br><span class="line">cursor for</span><br><span class="line">select avg(g.分数) from curriculum c, grade g where c.课程编号=g.课程编号 and c.课程名称=name;</span><br></pre></td></tr></table></figure>
<h2 id="2-da-kai-you-biao">2、打开游标</h2>
<p>声明游标之后，要想从游标中提取数据，必须首先打开游标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 游标名;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，打开一个游标时，游标并不指向第一条记录，而是指向第一条记录的前边。</p>
<p>在程序中，一个游标可以打开多次。用户打开游标后，其他用户或程序可能正在更新数据表，所以有时会导致用户每次打开游标后，显示的结果都不同。所以记得关闭游标（在下面）。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open classCursor;</span><br></pre></td></tr></table></figure>
<h2 id="3-shi-yong-you-biao">3、使用游标</h2>
<p>可以使用 <code>FETCH</code> 语句分别访问它的每一行。<code>FETCH</code> 指定检索什么数据（所需的列），检索出来的数据存储在什么地方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch classCursor into 变量名1, ...</span><br></pre></td></tr></table></figure>
<p>使用游标类似高级语言中的数组遍历，当第一次使用游标时，此时游标指向结果集的第一条记录。</p>
<p>MySQL 的游标是只读的，也就是说，你<strong>只能顺序地从开始往后读取</strong>结果集，不能从后往前，也不能直接跳到中间的记录。</p>
<p>例如：</p>
<p>从第一行到最后一行，循环检索当前行的 order_num 列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 遍历所有行</span><br><span class="line">repeat</span><br><span class="line">	fetch ordernumbers into k;</span><br><span class="line">-- end of loop</span><br><span class="line">until done end repeat;</span><br></pre></td></tr></table></figure>
<p>这个例子使用 <code>FETCH</code> 检索当前 <code>ordernumbers</code> 到声明的名为 <code>k</code> 的变量中。但与前一个例子不一样的是，这个例子中的 <code>FETCH</code> 是在 <code>REPEAT</code> 内，因此它反复执行直到 <code>done</code> 为真</p>
<p>当然，变量 <code>k</code> 需要在此之前需先声明</p>
<h2 id="4-guan-bi-you-biao">4、关闭游标</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close 游标名;</span><br></pre></td></tr></table></figure>
<p>在函数或存储过程中，如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create procedure avg_func(name varchar(50))</span><br><span class="line">begin</span><br><span class="line">declare res decimal;</span><br><span class="line">declare classCursor cursor for</span><br><span class="line">select avg(g.分数) from curriculum c, grade g where c.课程编号=g.课程编号 and c.课程名称=name;</span><br><span class="line">open classCursor;</span><br><span class="line">fetch classCursor into res;</span><br><span class="line">close classCursor;</span><br><span class="line">select res 平均分;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<h1 id="chuang-jian-han-shu">创建函数</h1>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create function 函数名(变量名 变量类型)</span><br><span class="line">returns 返回值类型</span><br><span class="line">begin</span><br><span class="line">...</span><br><span class="line">return 返回值</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<hr>
<p>若出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>
<p>则：</p>
<p><strong>临时生效，重启后失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=TRUE;</span><br></pre></td></tr></table></figure>
<p><strong>永久生效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
<h1 id="suo-yin">索引</h1>
<p>只有表才能创建索引</p>
<p>如果是<code>char</code>，<code>varchar</code>类型，<code>length</code> 可以小于字段实际长度；如果是 <code>blob</code> 和 <code>text</code> 类型，必须指定 <code>length</code>。</p>
<ul>
<li>创建<strong>普通</strong>索引（它没有任何限制）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名(属性1[(length)], ..);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>修改表索引</p>
<ul>
<li>
<p>添加索引（也可以用来创建索引）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add index 索引名(属性1, ..);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名 on 表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>创建表时，创建索引：</p>
</li>
</ul>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">    id int not null,</span><br><span class="line">    username varchar(16) not null,</span><br><span class="line">    index indexname(username(10))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>删除索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名 on 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建<strong>唯一</strong>索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index 索引名 on 表名(属性1[(length)], ..);</span><br></pre></td></tr></table></figure>
<h1 id="shi-tu">视图</h1>
<p>视图是一个虚拟表，其内容由查询定义。与table一样，同样能执行查询修改操作，不过其修改内容直接同步到原表。一般不要在视图上修改。</p>
<h2 id="chuang-jian-shi-tu">创建视图</h2>
<p>创建视图由 <code>select</code> 操作筛选出来</p>
<p>两种写法：</p>
<ul>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名 as select操作;</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名(属性名, ...) as select操作;</span><br></pre></td></tr></table></figure>
<h2 id="cha-kan-shi-tu">查看视图</h2>
<p>与查看 <code>table</code> 一样</p>
<ul>
<li>查看视图属性：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">或</span><br><span class="line">describe 视图名;</span><br></pre></td></tr></table></figure>
<p>前者命令只是后者的<strong>缩写</strong></p>
<ul>
<li>查看视图数据：与查看 <code>table</code> 一样，用 <code>select</code> 操作</li>
</ul>
<h2 id="xiu-gai-shi-tu">修改视图</h2>
<p>修改视图属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter view 视图名(属性1, ..) as select操作;</span><br></pre></td></tr></table></figure>
<p>和创建新视图差不多</p>
<h2 id="geng-xin-shi-tu">更新视图</h2>
<p>修改视图中的数据会修改原表的数据，一般不要直接从视图修改。</p>
<ul>
<li>修改某一条数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update view 视图名 set 属性名=... where 定位;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加一条数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into 视图名 values(数据1, ..);</span><br><span class="line">或</span><br><span class="line">insert into 视图名(属性1, ..) values(数据1, ..);</span><br></pre></td></tr></table></figure>
<p>与 <code>table</code> 一样</p>
<ul>
<li>删除一条数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 视图名 where 定位;</span><br></pre></td></tr></table></figure>
<p>与 <code>table</code> 一样</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2022/03/05/C++/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/05/C++/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/" itemprop="url">内建函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-05T22:45:00+08:00">
                2022-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="统计某个数-x-二进制中有多少个1"><a href="#统计某个数-x-二进制中有多少个1" class="headerlink" title="统计某个数 $x$ 二进制中有多少个1"></a>统计某个数 $x$ 二进制中有多少个1</h1><p><code>__builtin_popcount(unsigned x)</code></p>
<p><code>__builtin_popcountll(unsigned long long x)</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2022/02/12/Linux/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/12/Linux/Linux/" itemprop="url">Linux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-12T01:23:17+08:00">
                2022-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令"></a>常用文件管理命令</h2><ul>
<li><p>  <code>ctrl + c</code>： 取消命令，并且换行</p>
</li>
<li><p>  <code>ctrl + u</code>： 清空本行命令</p>
</li>
<li><p>  <code>tab键</code>： 可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p>
</li>
<li><p><code>ls</code>： 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p>
<ul>
<li><p>  可以加上路径，则列出路径中文件夹下所有文件</p>
</li>
<li><p>  <code>-a</code>： 查看全部文件，包括隐藏文件（<code>.XXX</code> 点开头的文件即为隐藏文件）</p>
</li>
</ul>
</li>
<li><p>  <code>pwd</code>： 显示当前路径</p>
</li>
<li><p>  <code>cd XXX</code>： 进入XXX目录下， <code>cd ..</code>： 返回上层目录</p>
</li>
<li><p>  <code>cp XXX YYY</code>： 将XXX文件复制成YYY，XXX和YYY可以是一个路径</p>
</li>
<li><p><code>mkdir XXX</code>： 创建目录XXX</p>
<ul>
<li>  创建多级目录： <code>-p</code> </li>
</ul>
</li>
<li><p><code>rm XXX</code>： 删除普通文件</p>
<ul>
<li><p>  <code>-r</code>： 删除文件夹</p>
</li>
<li><p>  <code>-rf</code>：加权限删除文件夹</p>
</li>
</ul>
</li>
<li><p><code>mv XXX YYY</code>： 将XXX文件移动到YYY，和 cp 命令一样，XXX和YYY可以是一个路径；</p>
<ul>
<li>  重命名也是用这个命令</li>
</ul>
</li>
<li><p>  <code>touch XXX</code>： 创建一个文件，需要自己写后缀名，如 <code>test.txt</code></p>
</li>
<li><p>  <code>cat XXX</code>： 展示文件XXX中的内容</p>
</li>
<li><p>  复制文本 windows/Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code></p>
</li>
<li><p>  粘贴文本 windows/Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p>
</li>
</ul>
<h2 id="用户和组操作"><a href="#用户和组操作" class="headerlink" title="用户和组操作"></a>用户和组操作</h2><ul>
<li>  <code>su 用户名</code>：切换用户</li>
<li>  <code>id 用户名</code>：查看用户所有属性</li>
<li><code>adduser 用户名</code>：创建用户<ul>
<li>  <code>—-gid ID</code>：将用户归到gid为ID的组下</li>
<li>  <code>—-uid ID</code>：将用户的uid设置为ID</li>
</ul>
</li>
<li>  <code>deluser 用户名</code>：删除用户</li>
<li><code>useradd 用户名</code>：创建用户<ul>
<li>  <code>-m</code>：生成家目录</li>
<li>  <code>-u ID</code>：指定用户uid</li>
<li>  <code>-g ID</code>：指定用户分配入为ID的组</li>
</ul>
</li>
<li>  <code>userdel -r 用户名</code>：删除用户</li>
<li><code>useradd</code> 和 <code>adduser</code> 区别：<ul>
<li>  <code>useradd</code> 需要手动配置，手动创建家目录，而 <code>adduser</code> 一气呵成</li>
<li>  同理删除用户命令也一样。</li>
</ul>
</li>
<li><code>addgroup 组名</code>：创建组<ul>
<li>  <code>—-gid ID</code>：指定组的gid</li>
</ul>
</li>
<li>  <code>delgroup 组名</code>：删除组</li>
<li>  <code>groupadd 组名</code> 和 <code>groupdel 组名</code>：同上，需手动</li>
<li><code>groupmod</code>：修改组的属性<ul>
<li>  <code>-g ID 组名</code>：修改该组gid为ID</li>
<li>  <code>-n 新组名 旧组名</code>：修改组名</li>
</ul>
</li>
<li>  <code>usermod -aG sudo 用户名</code>：在 $root$ 用户下给某个用户分配 $sudo$ 权限</li>
<li>  <code>usermod -l new_username old_username</code>：在 $root$ 用户下重命名某个用户</li>
<li>  <code>sudo passwd</code>：修改当前用户密码</li>
<li>  <code>passwd 用户名</code>：修改某用户密码 </li>
</ul>
<h2 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h2><ul>
<li><code>top</code>：查看所有进程的信息（Linux的任务管理器）<ul>
<li>  打开后，输入<code>M</code>：按使用内存排序</li>
<li>  打开后，输入<code>P</code>：按使用CPU排序</li>
<li>  打开后，输入<code>q</code>：退出</li>
</ul>
</li>
<li>  <code>df -h</code>：查看硬盘使用情况</li>
<li>  <code>free -h</code>：查看内存使用情况</li>
<li>  <code>du -sh</code>：查看当前目录占用的硬盘空间</li>
<li>  <code>ps aux</code>：查看所有进程</li>
<li><code>kill -9 pid</code>：杀死编号为pid的进程<ul>
<li>  传递某个具体的信号：<code>kill -s SIGTERM pid</code></li>
</ul>
</li>
<li>  <code>netstat -nt</code>：查看所有网络连接</li>
<li>  <code>w</code>：列出当前登陆的用户</li>
<li>  <code>ping www.baidu.com</code>：检查是否连网</li>
</ul>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>文件权限由10位组成，如：<code>drwxrwxr-x</code></p>
<p>第一位如果是d，那就是文件夹，否则为<code>-</code>，<code>r</code>为可读，<code>w</code>为可写，<code>x</code>为可执行</p>
<img src="http://duegin.gitee.io/pic/pictures/Linux/Linux文件权限.png" alt="Linux文件权限" style="zoom:61%;">

<ul>
<li>  <code>ll</code>：查看当前目录下所有文件的权限</li>
<li>  <code>chmod</code>：修改文件权限</li>
<li>  <code>chmod +x xxx</code>：给xxx添加可执行权限</li>
<li>  <code>chmod -x xxx</code>：去掉xxx的可执行权限</li>
<li>  <code>chmod 777 xxx</code>：将xxx的权限改成777 （三位）</li>
<li>  <code>chmod 777 xxx -R</code>：递归修改整个文件夹的权限</li>
</ul>
<h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ul>
<li>  <code>find /path/to/directory/ -name &#39;*.py&#39;</code>：搜索某个文件路径下的所有<code>*.py</code>文件</li>
<li>  <code>grep xxx</code>：从 $stdin$ 中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</li>
<li><code>wc</code>：统计行数、单词数、字节数<ul>
<li>  既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</li>
<li>  <code>wc -l</code>：统计行数</li>
<li>  <code>wc -w</code>：统计单词数</li>
<li>  <code>wc -c</code>：统计字节数</li>
</ul>
</li>
<li><code>tree</code>：展示当前目录的文件结构<ul>
<li>  <code>tree /path/to/directory/</code>：展示某个目录的文件结构</li>
<li>  <code>tree -a</code>：展示隐藏文件</li>
</ul>
</li>
<li>  <code>ag xxx</code>：搜索当前目录下的所有文件，检索xxx字符串</li>
<li><code>cut</code>：分割一行内容<ul>
<li>  从stdin中读入多行数据</li>
<li>  <code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li>
<li>  <code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li>
<li>  <code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li>
<li>  <code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li>
</ul>
</li>
<li><code>sort</code>：将每行内容按字典序排序<ul>
<li>  可以从stdin中读取多行数据</li>
<li>  可以从命令行参数中读取文件名列表</li>
</ul>
</li>
<li><code>xargs</code>：将stdin中的数据用空格或回车分割成命令行参数<ul>
<li>  <code>find . -name &#39;*.py&#39; | xargs cat | wc -l</code>：统计当前目录下所有python文件的总行数</li>
<li>  例如<code>cat</code> 需要传入文件参数，则不能直接从stdin中读取，而需要先通过<code>xargs</code>转成命令所需参数</li>
</ul>
</li>
</ul>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ul>
<li><code>more</code>：浏览文件内容<ul>
<li>  <code>回车</code>：下一行</li>
<li>  <code>空格</code>：下一页</li>
<li>  <code>b</code>：上一页</li>
<li>  <code>q</code>：退出</li>
</ul>
</li>
<li><code>less</code>：与more类似，功能更全<ul>
<li>  <code>回车</code>：下一行</li>
<li>  <code>y</code>：上一行</li>
<li>  <code>Page Down</code>：下一页</li>
<li>  <code>Page Up</code>：上一页</li>
<li>  <code>q</code>：退出</li>
</ul>
</li>
<li><code>head -3 xxx</code>：展示xxx的前3行内容<br>  同时支持从stdin读入内容</li>
<li><code>tail -3 xxx</code>：展示xxx末尾3行内容<br>  同时支持从stdin读入内容</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><code>md5sum</code>：计算md5哈希值<ul>
<li>  可以从stdin读入内容</li>
<li>  也可以在命令行参数中传入文件名列表；</li>
</ul>
</li>
<li>  <code>time command</code>：统计command命令的执行时间</li>
<li><code>ipython3</code>：交互式python3环境。可以当做计算器，或者批量管理文件。<ul>
<li>  <code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li>
</ul>
</li>
<li>  <code>watch -n 0.1 command</code>：每0.1秒执行一次command命令</li>
<li><code>tar</code>：压缩文件<ul>
<li>  <code>tar -zcvf xxx.tar.gz /path/to/file/</code>：压缩</li>
<li>  <code>tar -zxvf xxx.tar.gz</code>：解压</li>
</ul>
</li>
<li>  <code>diff xxx yyy</code>：查找文件xxx与yyy的不同点</li>
<li><code>crontab</code>：定期执行程序的命令<ul>
<li>  crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</li>
<li>  <strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</li>
<li>参数：<ul>
<li>  <code>-r</code>：删除目前的时程表</li>
<li>  <code>-l</code>：列出目前的时程表</li>
</ul>
</li>
<li>  具体如何设定时间表，现查现用–&gt;<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-crontab.html">菜鸟教程</a> </li>
</ul>
</li>
</ul>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul>
<li>  <code>sudo command</code>：以 $root$ 身份执行 $command$ 命令</li>
<li>  <code>apt-get install xxx</code>：安装软件</li>
<li>  <code>pip install xxx --user --upgrade</code>：安装$python$包</li>
</ul>
<h2 id="C-编译链接命令"><a href="#C-编译链接命令" class="headerlink" title="C++编译链接命令"></a>C++编译链接命令</h2><p>编译链接并命名为<code>main</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>



<p>只编译—&gt; 生成<code>.o</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp</span><br></pre></td></tr></table></figure>

<p>链接<code>.o</code>文件，生成名为<code>main</code>的可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>-l</code>：指定所使用到的函数库</li>
<li>  <code>-L</code>：指定函数库所在的文件夹</li>
<li>  <code>-I</code>：指定头文件所在的文件夹</li>
<li>  <code>-O2</code>：开启O2优化</li>
<li>  <code>-Wall</code>：打印gcc提供的警告信息</li>
<li>  <code>-std=c++11</code>：指定c++版本为11</li>
</ul>
<p>链接所有<code>.o</code>文件以及<code>thrift</code>库和线程库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o -lthrift -pthread</span><br></pre></td></tr></table></figure>

<p>至于这里的thread为啥用<code>-p</code>，是<code>gcc</code>手册里规定的</p>
<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>主要用途：</p>
<ul>
<li>  分屏</li>
<li>  允许断开Terminal连接后，继续运行进程。</li>
</ul>
<blockquote>
<p>  结构：<br>      一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。</p>
<p>  tmux:</p>
<ul>
<li>session 0:<ul>
<li>window 0:<ul>
<li>  pane 0</li>
<li>  pane 1</li>
<li>  pane 2</li>
<li>  …</li>
</ul>
</li>
<li>  window 1</li>
<li>  window 2</li>
<li>  …</li>
</ul>
</li>
<li>  session 1</li>
<li>  session 2</li>
<li>  …</li>
</ul>
</blockquote>
<p>当打开新的tmux时，已经在pane中了，当window中没有pane时，其window会退出，当session没有window时，其session也会退出</p>
<p>操作：</p>
<ol>
<li><p>  <code>tmux</code>：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</p>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>%</code>：将当前pane左右平分成两个pane。</p>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>&quot;</code>（注意是双引号”）：将当前pane上下平分成两个pane。</p>
</li>
<li><p>  <code>Ctrl + d</code>：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</p>
</li>
<li><p>选择pane：</p>
<ul>
<li>  鼠标点击pane</li>
<li>  按下 <code>Ctrl + a</code> 后手指松开，然后按方向键</li>
</ul>
</li>
<li><p>调整分割线位置：</p>
<ul>
<li><p>  鼠标拖动pane之间的分割线</p>
</li>
<li><p>  按住ctrl + a的同时按方向键</p>
</li>
</ul>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>z</code>：将当前pane全屏/取消全屏。</p>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>d</code>：挂起当前session。</p>
</li>
<li><p>  <code>tmux a</code>：打开之前挂起的session。</p>
</li>
<li><p>按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>s</code>：选择其它session。</p>
<ul>
<li>  方向键 —— 上：选择上一项 session/window/pane</li>
<li>  方向键 —— 下：选择下一项 session/window/pane</li>
<li>  方向键 —— 右：展开当前项 session/window</li>
<li>  方向键 —— 左：闭合当前项 session/window</li>
</ul>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>c</code>：在当前session中创建一个新的window。</p>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>w</code>：选择其他window，操作方法与(12)完全相同。</p>
</li>
<li><p>翻阅当前pane的内容：</p>
<ul>
<li>  鼠标滚轮</li>
<li>  按下 <code>Ctrl + a</code> 后手指松开，然后按 <code>PageUp</code>  / <code>PageDown</code></li>
</ul>
</li>
<li><p>选中文本：</p>
<ul>
<li><p>  在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</p>
</li>
<li><p>tmux中复制/粘贴文本的<strong>通用方式</strong>：</p>
<ol>
<li><p>  按下 <code>Ctrl + a</code> 后松开手指，然后按 <code>[</code></p>
</li>
<li><p>  用鼠标选中文本，被选中的文本会被自动复制到<strong>tmux的剪贴板</strong></p>
</li>
<li><p>  按下 <code>Ctrl + a</code> 后松开手指，然后按 <code>]</code>，会将剪贴板中的内容粘贴到光标处</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>想要复制选中的文本到Linux外面，只能通过 <code>Ctrl + insert</code> 复制</p>
<h1 id="vim教程"><a href="#vim教程" class="headerlink" title="vim教程"></a>vim教程</h1><p>功能：</p>
<ol>
<li><p>  命令行模式下的文本编辑器。</p>
</li>
<li><p>  根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</p>
</li>
<li><p>使用方式：<code>vim filename</code></p>
<ul>
<li><p>  如果已有该文件，则打开它。</p>
</li>
<li><p>  如果没有该文件，则打开个一个新的文件，并命名为filename</p>
</li>
<li><p>模式：</p>
<ul>
<li><p>一般命令模式</p>
<pre><code>  默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
</code></pre>
</li>
<li><p>编辑模式</p>
<p>  ​    在一般命令模式里按下i，会进入编辑模式。<br>  ​    按下ESC会退出编辑模式，返回到一般命令模式。</p>
</li>
<li><p>命令行模式</p>
<p>  ​    在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。</p>
<p>  ​    可以查找、替换、保存、退出、配置编辑器等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令行和一般命令模式操作：</p>
<ol>
<li><p>  <code>i</code>：进入编辑模式</p>
</li>
<li><p>  <code>&lt;ESC&gt;</code>：进入一般命令模式</p>
</li>
<li><p>移动光标：</p>
<ul>
<li><p>  方向键</p>
</li>
<li><p><code>h j k l</code>：</p>
<p>  ​    <code>h</code>： 左箭头键</p>
<p>  ​    <code>j</code>：下箭头键</p>
<p>  ​    <code>k</code>：上箭头键</p>
<p>  ​    <code>l</code>：右箭头键</p>
</li>
</ul>
</li>
<li><p>  <code>n&lt;Space&gt;</code>：<code>n</code>表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</p>
</li>
<li><p>  <code>0</code> 或 功能键 <code>[Home]</code>：光标移动到本行开头</p>
</li>
<li><p>  <code>$</code> 或 功能键 <code>[End]</code>：光标移动到本行末尾</p>
</li>
<li><p>  <code>G</code>：光标移动到最后一行</p>
</li>
<li><p>  <code>:n</code> 或 <code>nG</code>：n为数字，光标移动到第n行</p>
</li>
<li><p>  <code>gg</code>：光标移动到第一行，相当于 <code>1G</code></p>
</li>
<li><p>  <code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</p>
</li>
<li><p>查找某一字符串：</p>
<ul>
<li>  <code>/word</code>：向光标之下寻找第一个值为word的字符串。</li>
<li>  <code>?word</code>：向光标之上寻找第一个值为word的字符串。</li>
<li>  <code>n</code>：重复前一个查找操作</li>
<li>  <code>N</code>：反向重复前一个查找操作</li>
</ul>
</li>
<li><p>替换某一字符串</p>
<ul>
<li>  <code>:n1,n2s/word1/word2/g</code>：<code>n1</code>与<code>n2</code>为数字，在第<code>n1</code>行与<code>n2</code>行之间寻找<code>word1</code>这个字符串，并将该字符串替换为<code>word2</code></li>
<li>  <code>:1,$s/word1/word2/g</code>：将全文的<code>word1</code>替换为<code>word2</code></li>
<li>  <code>:1,$s/word1/word2/gc</code>：将全文的<code>word1</code>替换为<code>word2</code>，且在替换前<strong>要求用户确认</strong>。</li>
</ul>
</li>
<li><p>  <code>v</code>：选中文本</p>
</li>
<li><p><code>d</code>：删除选中的文本，相当于剪切</p>
<ul>
<li>  删除后n位：<code>dn&lt;Space&gt;</code></li>
<li>  删除到第n行：<code>dnG</code></li>
</ul>
</li>
<li><p>  <code>dd</code>：删除当前行，相当于剪切</p>
</li>
<li><p>  <code>y</code>：复制选中的文本，与删除操作类似</p>
</li>
<li><p>  <code>yy</code>：复制当前行</p>
</li>
<li><p><code>p</code>：将复制/剪切的数据在光标的下一行/下一个位置粘贴</p>
<ol>
<li>  当复制（yy）/剪切（dd）一整行时，粘贴的位置会在光标本行的下一行</li>
<li>  当复制（y）/ 剪切（d）不为一整行时，粘贴的位置会在光标右移一个位置出粘贴</li>
<li>  注意手动选中整行复制（y）/剪切（d）仍为第2种情况</li>
</ol>
</li>
<li><p>  <code>u</code>：撤销</p>
</li>
<li><p>  <code>Ctrl + r</code>：取消撤销</p>
</li>
<li><p>  大于号 <code>&gt;</code>：将选中的文本整体向右缩进一次</p>
</li>
<li><p>  小于号 <code>&lt;</code>：将选中的文本整体向左缩进一次</p>
</li>
<li><p>  <code>:w</code> 保存</p>
</li>
<li><p>  <code>:w!</code> 强制保存</p>
</li>
<li><p>  <code>:q</code>  退出</p>
</li>
<li><p>  <code>:q!</code>  强制退出</p>
</li>
<li><p>  <code>:wq</code>  保存并退出</p>
</li>
<li><p>  <code>:set paste</code>  设置成粘贴模式，取消代码自动缩进</p>
</li>
<li><p>  <code>:set nopaste</code>  取消粘贴模式，开启代码自动缩进</p>
</li>
<li><p>  <code>:set nu</code>  显示行号</p>
</li>
<li><p>  <code>:set nonu</code>  隐藏行号</p>
</li>
<li><p>  <code>gg=G</code> ：将全文代码格式化</p>
</li>
<li><p>  <code>:noh</code>  关闭查找关键词高亮</p>
</li>
<li><p>  <code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</p>
</li>
<li><p>异常处理：</p>
<ul>
<li><p>  每次用vim编辑文件时，会自动创建一个<code>.filename.swp</code>的临时文件。</p>
</li>
<li><p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p>
<ul>
<li><p>  找到正在打开该文件的程序，并退出</p>
</li>
<li><p>  直接删掉该swp文件即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>具体参考<a target="_blank" rel="noopener" href="https://www.acwing.com/file_system/file/content/whole/index/content/2855883/">AcWing shell语法</a> 我觉得已经比较详细了，懒得整理了</p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><p><strong>远程登录服务器</strong></p>
<p><code>ssh user@hostname</code></p>
<ul>
<li>  <code>user</code>：用户名</li>
<li>  <code>hostname</code>：IP地址或域名</li>
</ul>
<p>第一次登陆时会提示是否要连接，输入<code>yes</code></p>
<p>这样会将该服务器的信息记录在<code>~/.ssh/known_hosts</code>文件中。</p>
<p>然后输入密码即可登录到远程服务器中。</p>
<p><strong>端口</strong></p>
<p>默认登录端口号为22，如果想登录某一特定端口：</p>
<p><code>ssh user@hostname -p 22</code></p>
<p><strong>配置文件</strong><br>创建文件 <code>~/.ssh/config</code></p>
<p>然后在文件中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后再使用服务器时，可以直接使用别名myserver1、myserver2</p>
<p>即<code>ssh myserver1</code></p>
<p><strong>密钥登陆</strong></p>
<p>创建密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>


<p>然后一直回车即可。</p>
<p>执行结束后，<code>~/.ssh/</code>目录下会多两个文件：</p>
<ul>
<li>  id_rsa：私钥</li>
<li>  id_rsa.pub：公钥</li>
</ul>
<p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p>
<p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的<code>~/.ssh/authorized_keys</code>文件里即可。</p>
<p>也可以使用如下命令一键添加公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure>



<p><strong>执行命令</strong></p>
<p>假如，我们有上百台服务器，但是每个服务器都只做同样的操作，完全没可能先ssh登陆到服务器执行操作，再ssh去到另一台服务器上做操作，这样效率显然太低，所以可以进行下面优化，ssh会帮助我们完成登陆服务器，执行完操作，退出服务器。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname ls -a</span><br></pre></td></tr></table></figure>

<p>结果会打印在本地终端</p>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单引号中的$i可以求值</span><br><span class="line">ssh myserver &#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;</span><br></pre></td></tr></table></figure>
<p>又或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双引号中的$i不可以求值</span><br><span class="line">ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;</span><br></pre></td></tr></table></figure>

<p>实在不行，其实可以将命令写入shell文件，然后执行文件即可</p>
<h2 id="scp传文件"><a href="#scp传文件" class="headerlink" title="scp传文件"></a>scp传文件</h2><p>命令格式：</p>
<p><strong>复制文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source destination</span><br></pre></td></tr></table></figure>
<p>将source路径下的文件复制到destination中</p>
<p><strong>复制文件夹</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r dir destination</span><br></pre></td></tr></table></figure>

<p>将dir文件夹复制到destination中</p>
<p>一次复制多个文件/文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source1 source2/dir destination</span><br></pre></td></tr></table></figure>




<blockquote>
<p>将本地家目录中的tmp文件夹复制到myserver服务器中的<code>/home/acs/</code>目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ~/tmp myserver:/home/acs/</span><br></pre></td></tr></table></figure>



<p>将本地家目录中的tmp文件夹复制到myserver服务器中的<code>~/homework/</code>目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ~/tmp myserver:homework/</span><br></pre></td></tr></table></figure>



<p>将myserver服务器中的<code>~/homework/</code>文件夹复制到本地的当前路径下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r myserver:homework .</span><br></pre></td></tr></table></figure>

</blockquote>
<p>注意：</p>
<ul>
<li>  终点路径只能有一个，但复制的文件路径可以有多个</li>
<li>  访问服务器文件时，默认从服务器家目录出发</li>
</ul>
<p>当然也可以指定端口，但是这里是：<code>-P</code></p>
<h1 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h1><p><a target="_blank" rel="noopener" href="https://thrift.apache.org/">thrift官网</a></p>
<p>作用：</p>
<ul>
<li>  实现多语言调用，且有现成的服务端和客户端框架可用</li>
</ul>
<p>使用：</p>
<ul>
<li><p>  先新建一个<code>xxx.thrift</code> 文件，用于存储不同语言间的通信接口</p>
</li>
<li><p>  使用<code>thrift -r --gen cpp xxx.thrift文件路径</code> 在当前目录生成代码框架</p>
</li>
<li><p><code>gen-cpp</code> 即为新生成的文件，里面的<code>xxx.skeleton.cpp</code> 就是服务端代码框架，需要修改里面的部分代码即可</p>
<ul>
<li>  如果不需要服务端，则应该把他删掉</li>
<li>  此cpp文件需要修改的就是在<code>xxx.thrift</code>中定义的接口的函数体</li>
<li>  以<code>cpp</code>为例，开多线程模式需要在官网 –&gt; C++ Tutorial 下的 Server 代码的main函数TThreadedServer的定义抄下来，还需要把上面的<code>CalculatorCloneFactory</code> 这一个类抄下来，需要注意的是，通篇<strong>需要改名字</strong></li>
</ul>
</li>
<li><p>服务端和客户端可用不同语言实现，客户端代码需要在 thrift官网 –&gt; Tutorial 上找到相关语言的client代码去复制下来，然后修改</p>
<ul>
<li>  以<code>cpp</code>为例，这个需要修改的就是<code>transport-&gt;open();</code> 和 <code>transport-&gt;close();</code>之间的代码</li>
</ul>
</li>
</ul>
<p>也可以通过上手项目来了解</p>
<p><a target="_blank" rel="noopener" href="https://git.acwing.com/DueGin/thrift_lesson">入门项目：实现一个按分值的匹配系统</a></p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p>
<p><strong>查看</strong><br>列出当前环境下的所有环境变量：</p>
<ul>
<li>  <code>env</code>  显示当前用户的变量</li>
<li>  <code>set</code>  显示当前shell的变量，包括当前用户的变量</li>
<li>  <code>export</code> 显示当前导出成用户变量的shell变量</li>
</ul>
<p><strong>修改</strong></p>
<p>如：修改环境变量PATH： <code>export PATH=...</code> ，但这种方法，当你重新登陆服务器时，则会又会恢复回去。</p>
<p>为了可持久化，可以加到<code>~/.bashrc</code> 下，因为每次登陆、ssh或者用tmux开一个新的pane时，都会先执行一遍<code>~/.bashrc</code>，为了方便，只需将修改加到最后一行即可，因为程序从上往下执行，修改完后，立即生效则需<code>source ~/.bashrc</code> 一下。</p>
<p>例如：将此<code>export PATH=/home/acs/homework/lesson_7/homework_0:$PATH</code>加到最后一行，则将<code>homework_0</code>文件夹添加到了PATH中，需要注意的是：添加文件夹时，不用写后面的<code>/</code>，而且每个参数都用<code>:</code>隔开，需要我们加上之前的PATH</p>
<p>如果我们想创建自己的命令，则可以将该文件或所在目录添加到环境变量的PATH中</p>
<p><strong>常见环境变量</strong></p>
<ul>
<li>  <code>HOME</code>：用户的家目录。</li>
<li>  <code>PATH</code>：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li>
<li>  <code>LD_LIBRARY_PATH</code>：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。</li>
<li>  <code>C_INCLUDE_PATH</code>：C语言的头文件路径，内容是以冒号分隔的路径列表。</li>
<li>  <code>CPLUS_INCLUDE_PATH</code>：CPP的头文件路径，内容是以冒号分隔的路径列表。</li>
<li>  <code>PYTHONPATH</code>：Python导入包的路径，内容是以冒号分隔的路径列表。</li>
<li>  <code>JAVA_HOME</code>：jdk的安装目录。</li>
<li>  <code>CLASSPATH</code>：存放Java导入类的路径，内容是以冒号分隔的路径列表。</li>
</ul>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><strong>概念</strong><br>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin</p>
<p><strong>要点</strong></p>
<ol>
<li>  管道命令仅处理stdout，会忽略stderr。</li>
<li>  管道右边的命令必须能接受stdin。</li>
<li>  多个管道命令可以串联。</li>
</ol>
<p><strong>与文件重定向的区别</strong></p>
<ul>
<li>  文件重定向左边为命令，右边为文件。</li>
<li>  管道左右两边均为命令，左边有stdout，右边有stdin</li>
</ul>
<p><strong>常用的管道命令</strong></p>
<ul>
<li><p>  <code>find . -name &#39;*.cpp&#39; | xargs cat | wc -l</code>：查看当前目录下<code>.cpp</code>文件的代码行数</p>
</li>
<li><p>  <code>find . -name &#39;*.py&#39; | xargs cat | grep xxx &gt; a.txt</code>：统计当前目录下<code>.py</code>文件有多少行代码包含<code>xxx</code>字符串且保存到<code>a.txt</code>中</p>
</li>
<li><p>  <code>cat xxx.txt | cut -d &#39; &#39; -f 1 &gt; a.txt</code>：将<code>xxx.txt</code>中以<code>空格</code>隔开的字符串第一列存入<code>a.txt</code>中</p>
</li>
<li><p><code>ipython3</code>中：</p>
<ul>
<li><p>计算$2^{112} + 3^{78}$并存入<code>xxx.txt</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = <span class="number">2</span> ** <span class="number">112</span> + <span class="number">3</span> ** <span class="number">78</span></span><br><span class="line">&gt; ! echo $t &gt; xxx.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>更多命令参考<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/overview/">docker官方文档</a></p>
<h2 id="启动-docker："><a href="#启动-docker：" class="headerlink" title="启动 docker："></a>启动 <code>docker</code>：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="设置开机启动："><a href="#设置开机启动：" class="headerlink" title="设置开机启动："></a>设置开机启动：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker.service</span><br><span class="line">sudo systemctl enable containerd.service</span><br></pre></td></tr></table></figure>

<p>用 <code>disable</code> 禁用开机启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable docker.service</span><br><span class="line">sudo systemctl disable containerd.service</span><br></pre></td></tr></table></figure>



<h2 id="镜像-images"><a href="#镜像-images" class="headerlink" title="镜像(images)"></a>镜像(images)</h2><ul>
<li>  <code>docker pull ubuntu:20.04</code>：拉取一个镜像</li>
<li>  <code>docker images</code>：列出本地所有镜像</li>
<li>  <code>docker image rm ubuntu:20.04</code> 或 <code>docker rmi ubuntu:20.04</code>：删除镜像<code>ubuntu:20.04</code></li>
<li>  <code>docker commit CONTAINER IMAGE_NAME:TAG</code>：创建某个<code>CONTAINER</code>的镜像</li>
<li>  <code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像<code>ubuntu:20.04</code>导出到本地文件<code>ubuntu_20_04.tar</code>中</li>
<li>  <code>docker load -i ubuntu_20_04.tar</code>：将镜像<code>ubuntu:20.04</code>从本地文件<code>ubuntu_20_04.tar</code>中加载出来</li>
</ul>
<h2 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h2><ul>
<li>  <code>docker create -it ubuntu:20.04</code>：利用镜像<code>ubuntu:20.04</code>创建一个容器。</li>
<li>  <code>docker run -p 20000:22 --name test -itd ubuntu:20.04</code>：利用镜像<code>ubuntu:20.04</code>创建并运行一个容器，且起名为 $test$ ，且本地端口号 $20000$ 映射到容器端口号 $22$</li>
<li><code>docker ps</code>：查看本地的所有正在运行的容器<ul>
<li>  <code>-a</code>：查看本地的所有容器</li>
</ul>
</li>
<li>  <code>docker start CONTAINER</code>：启动容器<code>CONTAINER</code></li>
<li>  <code>docker stop CONTAINER</code>：停止容器<code>CONTAINER</code></li>
<li>  <code>docker restart CONTAINER</code>：重启容器<code>CONTAINER</code></li>
<li><code>docker attach CONTAINER</code>：进入容器<code>CONTAINER</code><ul>
<li>  先按<code>Ctrl-p</code>，再按<code>Ctrl-q</code>可以挂起容器</li>
<li>  <code>Ctrl-d</code>，退出容器，且停止容器</li>
</ul>
</li>
<li>  <code>docker exec CONTAINER COMMAND</code>：在容器<code>CONTAINER</code>中执行命令<code>COMMAND</code></li>
<li>  <code>docker top CONTAINER</code>：查看容器<code>CONTAINER</code>内的所有进程</li>
<li>  <code>docker [container] rm CONTAINER</code>：删除容器<code>CONTAINER</code></li>
<li>  <code>docker container prune</code>：删除所有已停止的容器</li>
<li>  <code>docker export -o xxx.tar CONTAINER</code>：将容器<code>CONTAINER</code>导出到本地文件<code>xxx.tar</code>中</li>
<li>  <code>docker import xxx.tar image_name:tag</code>：将本地文件<code>xxx.tar</code>导入成镜像，并将镜像命名为<code>image_name:tag</code></li>
<li><code>docker export/import</code>与<code>docker save/load</code>的区别：<ul>
<li>  <code>export/import</code>会丢弃历史记录和元数据信息，仅保存容器当时的快照状态</li>
<li>  <code>save/load</code>会保存完整记录，体积更大</li>
</ul>
</li>
<li>  <code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</li>
<li>  <code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code>：在本地和容器<code>CONTAINER</code>间复制文件</li>
<li>  <code>docker rename old_name new_name</code>：重命名容器</li>
<li>  <code>docker update CONTAINER --memory 500MB</code>：修改容器<code>CONTAINER</code>限制</li>
</ul>
<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2022/01/23/%E7%AE%97%E6%B3%95/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/23/%E7%AE%97%E6%B3%95/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/" itemprop="url">线段树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-23T23:49:17+08:00">
                2022-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>所谓线段树，是一棵二叉树，用二叉树来维护区间中的某些信息</p>
<p>首先线段树中的每个点用<strong>结构体</strong>来存</p>
<p>其次包含基本五个操作：</p>
<ul>
<li>  初始化线段树 <code>build()</code></li>
<li>  子树更新根树信息 <code>pushup()</code></li>
<li>  往下传懒标记，并更新子树信息 <code>pushdown()</code> </li>
<li>  修改操作 <code>motify()</code></li>
<li>  查询操作 <code>query()</code></li>
</ul>
<p>这里假如区间有 n 个点，则需要开 $4n$ 倍多个结构体</p>
<p>因为最坏情况是一棵满二叉树，假如倒数第二层有 $n$ 个点，倒数第二层以前的点数是 $2n-1$ 个，最后一层最坏情况有 $2n$ 个点，加起来就是 $4n-1$ 个点，开 $4n$ 个点，最后一层就是为了防止如果不是 $2^k$ 的长度而开的</p>
<p>单点修改一般没有 <code>pushdown()</code> 操作，而区间修改使用 <code>pushdown()</code> 是给指定的区间操作时，完全被覆盖的区间不用再递归下去更新，用到的时候再更新子树信息，只需在修改时打上一个标记，表明操作内容即可。</p>
<img src="http://duegin.gitee.io/pic/pictures/2.数据结构/线段树概述.png" alt="线段树概述" style="zoom: 50%;">

<img src="http://duegin.gitee.io/pic/pictures/2.数据结构/线段树情况.png" alt="线段树情况" style="zoom:50%;">



<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 需要维护的信息和懒标记</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 利用左右儿子信息维护当前节点的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将懒标记下传</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, ...&#125;; <span class="comment">// 树底的信息</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 修改区间信息、懒标记等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 往下传懒标记，并更新左右儿子的 懒标记 和 其他信息</span></span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, l, r, d); <span class="comment">// mid左边有沾，则递归左边</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d); <span class="comment">// mid右边有沾，则递归右边</span></span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">// 回溯时更新根树u的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;  <span class="comment">// TODO 需要补充返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u); <span class="comment">// 往下传懒标记，并更新左右儿子的 懒标记 和 其他信息</span></span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid ) res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r); <span class="comment">// mid左边有沾，则递归左边</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r); <span class="comment">// mid右边有沾，则递归右边</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>合理运用<strong>单点修改</strong>和<strong>区间修改</strong>这两种做法</p>
<p>单点修改模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/247/">AcWing 246. 区间最大公约数</a> ，这题运用到了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF">更相减损术</a> $gcd(a,b,c)=&gt;gcd(a,b-a,c-b)=gcd(a,gcd(b-a,c-b))$</p>
<p>区间修改模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1279/">AcWing 1277. 维护序列</a> </p>
<p>线段错误树变种恶心题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/249/">AcWing 247. 亚特兰蒂斯</a></p>
<p>利用操作次数作为区间建树：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4588">TJ OI 2018数学计算</a></p>
<p>注意：</p>
<ul>
<li><p>  注意线段树点数有没有开<strong>区间长度</strong>的4倍</p>
</li>
<li><p>  注意线段树有交集的三种情况（上图有），在含有懒标记时，才可以统一判断，否则需要注意是否有跨区间操作，有则是上图的第三种情况（比如[**⌊**区间连续最大子段和**⌉**](AcWing 245. 你能回答这些问题吗)这题）</p>
</li>
<li><p>  只有在 <code>build()</code> 的时候取 $mid$ 才要用 $l$ 和 $r$ ，其他操作取 $mid$ 都是用 $tr[u].l$ 和 $tr[u].r$ </p>
</li>
<li><p>  注意 $pushup()$ 和 $pushdown()$ 的位置</p>
</li>
<li><p>  注意位运算有没有写错，或者可以写成 $2u$ 和 $2u+1$ </p>
</li>
<li><p>  在按下调试按钮时，做好心理准备出现CE，改完错误之后，大多是段错误SF，一般将SF调成WA那就是初步胜利了</p>
</li>
<li><p>  如果是提交时出现WA，大多可能是爆$int$ 了，需要开 $long \ long$ 来存</p>
</li>
<li><p>TLE的话，首先看看有没有什么可以优化的，举几个例子：</p>
<ul>
<li><p>  前缀和：查询区间和时可以使用</p>
</li>
<li><p>  差分：区间加法时能用，具体可以去看<strong>⌊</strong>区间最大公约数<strong>⌉</strong>那道题。</p>
</li>
<li><p>  二分：优化查找部分，一般和离散化配套使用。</p>
</li>
<li><p>  离散化：具体去看<strong>⌊</strong>亚特兰蒂斯<strong>⌉</strong>那道题。</p>
</li>
<li><p>  dp：线段树优化dp，很难了，去学闫式dp分析法吧。</p>
</li>
</ul>
</li>
</ul>
<p>错误树调试方法：</p>
<ol>
<li>  先通读一遍看看有没有粗心或者明显的逻辑错误</li>
<li>  然后调整输入数据，一般将操作的次数调为0，查看是否是初始化的问题 <code>build()</code> ，一般我都是忘了在<code>main</code>中写这个<code>build()</code></li>
<li>  再按输入数据分别排查 <code>modify()</code> 和 <code>query()</code> ，同时这两个牵连的 <code>pushup()</code> 和  <code>pushdown()</code> 比较麻烦</li>
<li>  最后调不出来的话，输出一下每个操作后的 $tr$ 数组</li>
<li>  实在不行就代码比对大法，比赛或者考试就没撤了</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2022/01/14/%E7%AE%97%E6%B3%95/1.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/%E7%A6%BB%E6%95%A3%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/14/%E7%AE%97%E6%B3%95/1.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/%E7%A6%BB%E6%95%A3%E5%8C%96/" itemprop="url">离散化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-14T13:52:17+08:00">
                2022-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>离散化是哈希的一种特殊形式，我觉得也是映射，<strong>值映射到下标</strong></p>
<p>适用于：整个<strong>数据范围跨度很大</strong>，但只用的数据不多，很稀疏</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/804/">AcWing 802. 区间和</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值，其实他们的下标可以认为是他们的离散化坐标</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= alls[mid]) <span class="comment">// 返回第一个大于等于x的下标</span></span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n（看你选择，这是下标从1开始的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实你直接可以认为<code>alls[]</code> 的值所离散化的下标就是他们在 <code>alls[]</code> 中的下标，只是需要查找到这个值，大部分题一般先排序，对解题有用，然后顺便用二分查找到这个值。</p>
<p>离散化有个问题就是<strong>需要去重，这是必然的</strong>，因为重复元素再次映射会影响到结果</p>
<p>当然这个去重函数 <code>unique()</code> 用在 <code>vector</code> 上的，他是将重复元素放到数组后面，并返回第一个重复元素的迭代器</p>
<p>离散化题目其实可以用 <code>map</code> 偷懒，map内部帮你内部排序好了，且无重复key值</p>
<p>题型：</p>
<ul>
<li><p>纯离散</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2016/">AcWing 2014. 岛</a> USACO 2012（将所有连续重复高度的岛合为一个岛，再分情况讨论）</li>
</ul>
</li>
<li><p>离散 + 差分</p>
<ul>
<li>  模板题： <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/804/">AcWing 802. 区间和</a> </li>
<li>变种：<ul>
<li>  <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1954/">AcWing 1952. 金发姑娘和 N 头牛</a> USACO 2013（将产量看成代价，再分区间 $[0,a-1]$、$[a,b]$、$[b+1,+∞]$）</li>
<li>  <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1989/">AcWing 1987. 粉刷栅栏</a> USACO 2013（计算差分和时，判断哪些被刷过两次即可）</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/23/%E7%AE%97%E6%B3%95/4.%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/23/%E7%AE%97%E6%B3%95/4.%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/" itemprop="url">数论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-23T00:39:17+08:00">
                2021-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>方法：</p>
<ul>
<li>试除法判定质数</li>
<li>试除法分解质因数</li>
<li>埃氏筛法求素数</li>
<li>线性筛法求素数</li>
</ul>
<h2 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h2><p>时间复杂度 $O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/868/">AcWing 866. 试除法判定质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 x 是否为质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断1和0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">//从1～sqrt(x)里找即可</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只需遍历到 $\sqrt{x}$ 的原因是：<br>一个数的因数都是<strong>成对存在的</strong>，即：<br>$d&lt;={x}/{d}$， $d^2&lt;=x$，$d&lt;=\sqrt{x}$</p>
<p>例如12的因数有3和4，2 和6，所以我们可以只枚举较小的那一个，即 $\sqrt{x}$ ，假设较小的为d，较大的为 x/d<br>其实我认为：$x$ 质因数边界就是 $\sqrt{x}$</p>
</blockquote>
<h2 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h2><p>时间复杂度：$O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/869/">AcWing 867. 分解质因数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 级数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#4">埃拉托斯特尼筛法</a>，简称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%B0%8F%E7%AD%9B/5677377">埃氏筛</a>或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于 $\sqrt{x}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>要得到自然数n以内的全部素数，必须把不大于 $\sqrt{n}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>时间复杂度 $O(nloglogn)$</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有质数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 筛选 2～n 的所有数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i; <span class="comment">// 将 i 存入质数数组中</span></span><br><span class="line">        <span class="comment">// 质数的倍数绝对不是质数，把所有质数的倍数全部丢弃</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) <span class="comment">// 将i的所有倍数筛掉，j就是几倍，而 n/i则是i的最大倍数，小学数学</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  给出要筛数值的范围n，找出以内的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个质数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个质数5筛，把5留下，把5的倍数剔除掉；不断重复下去……</p>
</blockquote>
<h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>线性筛法，也叫欧拉筛法，是在埃氏筛法的基础上做出优化，我们发现这里面似乎会对某些数标记了很多次其为合数，而线性筛法利用其最小质因数来筛掉合数，每次只标记一次</p>
<p>时间复杂度 $O(n)$ ，数据量小于1e7的情况下，线性筛法和埃氏筛法差不多，数据量大于1e7则线性筛法比埃氏筛法快一倍</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 用最小质因子去筛合数 primes[j] * i</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果 i 是合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(i%prime[j]==0) break;</code> 这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/线性筛法例子.png" alt="线性筛法例子" style="zoom:75%;">

<p>例如，$i=6$ 时，第一个素数是2，能整除，筛掉12后就 break；至于第二个素数3，6x3中的最小素因数肯定是素数2，所以它要到 $i=9$，素数取2时才被筛掉。</p>
<ol>
<li><p>  当 <code>i % primes[j] != 0</code> 时，说明此时遍历到的 <code>primes[j]</code> 不是 <code>i</code> 的质因子，那么只可能是此时的 <code>primes[j] * i</code> 的最小质因子，所以 <code>primes[j] * i</code> 的最小质因子就是 <code>primes[j]</code> </p>
</li>
<li><p>  当有 <code>i % primes[j] == 0</code> 时，说明 <code>i</code> 的最小质因子是 <code>primes[j]</code> ， 因此 <code>primes[j] * i</code> 的最小质因子也就应该是 <code>prime[j]</code>，之后接着用 <code>st[primes[j + 1] * i] = true</code> 去筛合数时，就不是用最小质因子去更新了，因为 <code>i</code> 有最小质因子 <code>primes[j]&lt;primes[j+1]</code>，此时的 <code>primes[j+1]</code>不是 <code>primes[j+1]*i</code> 的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</p>
</li>
</ol>
<blockquote>
<p>补充：一个数乘上合数肯定是合数，所以只需要让遍历到的数 i 乘上其最小质因数 <code>prime[j]</code> 即可，这样的话乘上后的数必是合数，且有质因数是 <code>prime[j]</code></p>
</blockquote>
<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>方法：</p>
<ul>
<li>试除法求所有约数</li>
<li>约数个数 和 约数之和</li>
<li>欧几里得算法</li>
</ul>
<p>n 与 1～n 的约数互为质数的个数：</p>
<ul>
<li>朴素求欧拉函数</li>
<li>筛法求欧拉函数</li>
</ul>
<h2 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h2><p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/871/">AcWing 869. 试除法求约数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回升序的x所有质数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  因为约数都是成对存在的，所以只需要遍历到 $\sqrt{x}$ 即可，具体看<strong>试除法求质数</strong></p>
</blockquote>
<blockquote>
<p>  第9行：防止当约数重复加入，如25=5*5</p>
</blockquote>
<h2 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86/4926961">约数个数定理</a> </p>
<p>乘法原理，组合数学</p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>约数个数： $(c_1 + 1) \times (c_2 + 1) \times … \times (c_k + 1)$ </p>
<p>可以发现：约数个数和质因数是啥无关</p>
<blockquote>
<p>  百科例题：正整数 378000 共有多少个正约数？</p>
<p>  解：将 378000 分解质因数$378000=2^4×3^3×5^3×7^1$</p>
<p>  由约数个数定理可知378000共有正约数$(4+1)×(3+1)×(3+1)×(1+1)=160$个。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/872/">AcWing 870. 约数个数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h : m) res *= (h.second + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  这里的扫尾是因为，有可能最后除到 $x$ 是质数了，比如 7 或14 最后只能由扫尾加入 7 这个质因数</p>
</blockquote>
<h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428">约数和定理</a> </p>
<p>模板题： <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/873/">AcWing 871. 约数之和</a> </p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>约数之和： $(p_1^0 + p_1^1 + … + p_1^{c_1}) \times … \times (p_k^0 + p_k^1 + … + p_k^{c_k})$ </p>
<blockquote>
<p>  百科例题：正整数360的所有正约数的和是多少？</p>
<p>  解：将360分解质因数可得</p>
<p>  $360=2^3<em>3^2</em>5^1$</p>
<p>  由约数和定理可知，360所有正约数的和为</p>
<p>  $(2^0+2^1+2^2+2^3)×(3^0+3^1+3^2)×(5^0+5^1)=(1+2+4+8)(1+3+9)(1+5)=15×13×6=1170$</p>
<p>  可知360的约数有1、2、3、4、5、6、8、9、10、12、15、18、</p>
<p>  20、24、30、36、40、45、60、72、90、120、180、360；则它们的和为</p>
<p>  1+2+3+4+5+6+8+9+10+12+15+18+20+24+30+36+40+45+60+72+90+120+180+360=1170</p>
</blockquote>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x/i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h : m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p = h.first, c = h.second; <span class="comment">// p是底数，c是级数</span></span><br><span class="line">    LL t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c--) t = t * p + <span class="number">1</span>; <span class="comment">// pi^(0~ak)之和，也可以用等比求和</span></span><br><span class="line">    res *= t; <span class="comment">// 所有pi相乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>原理：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a></p>
<p>也叫辗转相除法</p>
<blockquote>
<p>  百科例子：</p>
<p>  假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：</p>
<p>  1997 / 615 = 3 (余 152)</p>
<p>  615 / 152 = 4(余7)</p>
<p>  152 / 7 = 21(余5)</p>
<p>  7 / 5 = 1 (余2)</p>
<p>  5 / 2 = 2 (余1)</p>
<p>  2 / 1 = 2 (余0)</p>
<p>  至此，最大公约数为1</p>
<p>  以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/874/">AcWing 872. 最大公约数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  这里a 和 b无论谁大都可用，我试过了</p>
</blockquote>
<h3 id="Stein算法"><a href="#Stein算法" class="headerlink" title="Stein算法"></a>Stein算法</h3><p>针对欧几里德算法在对大整数进行运算时，需要试商导致增加运算时间的缺陷，还有一种算法可对其优化：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Stein%E7%AE%97%E6%B3%95"><strong>Stein算法</strong></a> </p>
<h3 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%B3%95/10277459">更相减损法</a>有点类似于求最大公约数的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Stein%E7%AE%97%E6%B3%95">Stein算法</a>。在更相减损法中，若两个是偶数则同除以2，结果乘以2。如果增加一个判断，若为一奇一偶则偶数除以2，结果不变，若为两个奇数才相减，这样就变成了计算大整数最大公约数的非常好的一个算法，Stein算法。</p>
<p>第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。</p>
<p>第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。</p>
<p>则第一步中约掉的若干个2的积与第二步中等数的乘积就是所求的最大公约数。</p>
<blockquote>
<p>  百科例子：</p>
<p>  解：由于260和104均为偶数，首先用 2 约简得到 130 和 52，再用 2 约简得到 65 和 26。</p>
<p>  此时 65 是奇数而 26 不是奇数，故把 65 和 26 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%97%E8%BD%AC%E7%9B%B8%E5%87%8F/7529647">辗转相减</a>：</p>
<p>  65-26=39</p>
<p>  39-26=13</p>
<p>  26-13=13</p>
<p>  所以，260 与 104 的最大公约数等于 13 乘以第一步中约掉的两个2，即13<em>2</em>2=52。</p>
</blockquote>
<h3 id="区间最大公约数"><a href="#区间最大公约数" class="headerlink" title="区间最大公约数"></a>区间最大公约数</h3><p>同样用到了更相减损术</p>
<p>即：<code>t[]=&#123;a, b, c&#125;</code></p>
<p>$$<br>gcd(t)=&gt;gcd(a,b-a,c-b)=gcd(a,\ gcd(b-a,c-b))<br>$$<br>这里需要用差分来预处理再倒着 gcd 一遍即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n], s[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = s[i] - s[i - <span class="number">1</span>]; <span class="comment">// 差分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) res = <span class="built_in">gcd</span>(res, a[i]); <span class="comment">//gcd(a, b - a, c - b, d - c, ...)</span></span><br></pre></td></tr></table></figure>



<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>定理：</p>
<p>$$<br>(a,b) \times [a,b]=a \times b<br>$$</p>
<p>即需要用到 $gcd(a,b)$ 先求出最大公约数，再用两数之积除以 $d$</p>
<h2 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h2><p>在数论，对正整数 n，欧拉函数是小于 n 的正整数中与 n <a href="%E4%BA%92%E8%B4%A8%E6%98%AF%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E6%95%B4%E6%95%B0%E3%80%82%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%90%8E%E8%80%85%E6%98%AF%E5%89%8D%E8%80%85%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E3%80%82">^互质</a>的数的数目。</p>
<p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850">欧拉函数</a> 容斥原理</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/容斥原理.png" alt="容斥原理" style="zoom:61%;">

<p>N的质因数分解： $N=p_1^{c_1}\times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>与 N 互质的数的个数<strong>结论</strong>：</p>
<p> $φ(N)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ </p>
<p>$\ \ \ \ \ \ \ \ \ \ =N \times \frac{p_1-1}{p_1} \times \frac{p_2-1}{p_2}…\frac{p_k-1}{p_k}$ </p>
<p>可以发现：<strong>欧拉函数与质因数的级数无关</strong> </p>
<h3 id="朴素求法"><a href="#朴素求法" class="headerlink" title="朴素求法"></a>朴素求法</h3><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/875/">AcWing 873. 欧拉函数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 试除法求质因数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除后乘，防止溢出</span></span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>这个思路是利用了线性筛法来求欧拉函数，代码也在线性筛法的基础上作出了小修改，在求质因数的时候，用其最小质因数去更新其欧拉函数</p>
<p>思路（类似DP）：</p>
<ul>
<li>  先写出线性筛法模板</li>
<li>  多开一个 $euler[N]$ 数组存每个数的欧拉函数</li>
<li>分情况<ul>
<li>被筛掉的情况<ul>
<li>  被筛掉说明是质数，那他的欧拉函数就是 $i-1$ </li>
</ul>
</li>
<li>筛选时的情况<ul>
<li>  $primes[j]$ 为 $primes[j] \times i$ 的最小质因数</li>
<li><code>i % p[j] == 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times primes[j]$ </li>
</ul>
</li>
<li><code>i % p[j] != 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times (primes[j]−1)$ </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面 $primes[j]$ 用 $p[j]$ 表示</p>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>   $φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ 是 $i$ 的一个质因子，而且欧拉函数与质因子个数无关，所以在算 $p[j]\times i$ 分解质因子也是 $p_1 -&gt; p_k$ </p>
<p>  因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) $ </p>
<p>  即： $φ(p[j]\times i)=p[j]\times φ(i) $ </p>
</blockquote>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>$φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ <strong>不是</strong> $i$ 的一个质因子，所以 $p[j]\times i$ 与 $i$ 的质因子的区别就是前者比后者多一个 $p[j]$ </p>
<p>因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) \times (1-\frac{1}{p_j})$  </p>
<p>即： $φ(p[j]\times i)=p[j]\times φ(i) \times (1-\frac{1}{p_j})$ </p>
<p>即： $φ(p[j] \times i)=φ(i) \times (p[j]−1)$ </p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/876/">AcWing 874. 筛法求欧拉函数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 线性筛法求欧拉函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>; <span class="comment">// 质数的话，肯定是前面的数，除了0以外互质的数只有1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ ) <span class="comment">// 遍历质数，用最小质因数筛掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i; <span class="comment">// 质数*i </span></span><br><span class="line">            st[t] = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// 用最小质因数去更新其欧拉函数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">// i % p[j] == 0的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j]; <span class="comment">// 直接乘上其最小质因数的欧拉函数即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i % p[j] != 0的情况</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">// 这里是化简后的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  当 $i$ 未被标记时，即 $i$ 为质数，那肯定是前面的数，除了0以外只有1是互质的数</p>
</blockquote>
<p>背过吧…</p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>求 $a^k$  mod  $p$，时间复杂度 $O(logk)$ </p>
<p><strong>数学结论：</strong></p>
<p>传统方法是直接将 $a$ 乘 $b$ 次，但是算法复杂度是 $O(b)$ ，如果遇到 $b$ 很大的情况就很慢。</p>
<p>其实就是把幂转成二进制，然后来算</p>
<p>$$a^k=a^{2 \frac{k}{2}}=(a^2)^{\frac{k}{2}}$$ </p>
<p>如果把 k 转成二进制数 $(k)_{10}=(…bcd)_2$ </p>
<p>那么：<br> $$a^k=a^{d \  \cdot \ 2^0 + c \ \cdot \ 2^1 + b\ \cdot \ 2^2+ \ …}$$ </p>
<p> $$a^k=a^{d \  \cdot \ 2^0} \cdot a^{c \  \cdot \ 2^1} \cdot a^{b \  \cdot \ 2^3} \ …$$ </p>
<p>可以发现其实就是将幂拆成用二进制表示幂来算</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/877/">AcWing 875. 快速幂</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a^k%p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>,t = a;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) <span class="comment">// 取二进制个位</span></span><br><span class="line">            res = (LL)res * t % p; <span class="comment">//  把每一项乘起来</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">// k把个位去掉（右移一位）</span></span><br><span class="line">        t = (LL)t * t % p; <span class="comment">// 这个就是每一次的(a^2)的级数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  例子：</p>
<p>  求$5^{11}$</p>
<p>   $$5^{11}=5^{(1011)_2}$$ </p>
<p>   ​       $$=5^{2^3+2^1+2^0}$$ </p>
<p>  ​       $$=5^{2^3} \ \cdot \ 5^{2^1} \ \cdot \ 5^{2^0}$$ </p>
<p>  ​       $$=5^{8} \ \ \cdot \ 5^{2} \ \ \cdot \ 5^{1}$$ </p>
</blockquote>
<p>如此可以发现，与幂的二进制数上的每一位有关</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p> 给定一对正整数 a,b，求出一组 x,y，使其满足：</p>
<p> $$ax+by=gcd(a,b)$$</p>
<blockquote>
<p>贝祖定理：<br>​有一个线性不定方程<br>$ax+by=c$</p>
<p>若此方程有解，那么<br>$c=k·(a,b), k∈Z^+$ </p>
</blockquote>
<p>公式推导：</p>
<p>当 $b=0$ 时 $ax+by=a$ 故而 $x=1,y=0$，</p>
<p>当 $b≠0$ 时，因为<br>$$<br>gcd(a,b)=gcd(b,a%b)<br>$$</p>
<p>而<br>$$<br>bx′+(a%b)y′=gcd(b,a%b)<br>$$</p>
<p>$$<br>bx′+(a−⌊a/b⌋\times b)y′=gcd(b,a%b)<br>$$</p>
<p>$$<br>ay′+b(x′−⌊a/b⌋\times y′)=gcd(b,a%b)=gcd(a,b)<br>$$</p>
<p>故而求得<strong>通解</strong>：<br>$$<br>x=y′,y=x′−⌊a/b⌋\times y′<br>$$</p>
<p>因此可以采取递归算法 先求出下一层的 $x′$ 和 $y′$ 再利用上述公式回代即可</p>
<p>递归边界：当 $b=0$ 时，$(a,b)=a,x=1,y∈Z$</p>
<blockquote>
<p>特别的，用扩展欧几里得算法还可以求出乘法逆元。<br>$$<br>ax≡1mod \ p<br>$$</p>
<p>$$<br>ax+py=1<br>$$</p>
<p>当且仅当 $gcd(a,p)=1$ 时有解。</p>
</blockquote>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/879/">AcWing 877. 扩展欧几里得算法</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// 返回值是 a 和 b 的最大公约数，即: gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="comment">// 这是其中一组解</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>; <span class="comment">// 边界，当b=0时，手算出来的边界，a*x + 0*y = gcd(a, 0) = a</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">// 先求出下一层递归的 y = x&#x27; 和 x = y&#x27;</span></span><br><span class="line">    y -= (a / b) * x; <span class="comment">// y=x&#x27;−⌊a/b⌋*y&#x27;，这里的x&#x27;其实就是下一层递归的x，y&#x27;是下一层的y，因为上面交叉传了</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h2><blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  对任何整数 $a$、$b$ 和它们的最大公约数 $d$ ，满足：</p>
<p>  ​                                                                $$ax+by=d$$</p>
<p>  若$a$, $b$是整数，且 $gcd(a,b)=d$，那么对于任意的整数 $x$, $y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$, $y$，使得$ax+by=d$ 成立。</p>
</blockquote>
<p>当算一个线性同余方程 $ax_0+by_0=d$ 的通解时，我们可以发现 $a(x-\frac{b}{d})+b(y+\frac{a}{d})=d$ 为其中一组解</p>
<p>即其通解为：</p>
<p>​                                                                                        $$x=x_0-\frac{b}{d} \cdot k \ ,k∈Z$$</p>
<p>​                                                                                         $$y=y_0+\frac{a}{d} \cdot k \ , k∈Z$$</p>
<p>给定 $a$, $b$, $p$，求出 $x$ 使其满足</p>
<p>​                                                                        $$a \cdot x≡b \ mod \ p$$</p>
<p> 这个方程可以写为</p>
<p>​                                                                         $ax=py+b$  ，  将 $y = -y$ </p>
<p>即： $ax+py=b$</p>
<p>要使该方程有解，则满足</p>
<p>​                                                                        $$b=k \cdot gcd(a,p),k∈Z$$</p>
<p>用扩展欧几里得算法求出 $ax+py=(a,p)$ 的 $x$ 的解之后，再将 $x$ 乘上 $\frac{b}{(a,p)}$ 即可。</p>
<p>为什么要翻倍，因为我们需要求的是 $ax+py=b$ ，而 $(a,p)$ 是 $b$ 的倍数，所以两边同时翻倍即可</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/880/">AcWing 878. 线性同余方程</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// b不是d的倍数则无解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * b / d % p; <span class="comment">// 扩大b/d倍</span></span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exgcd()</code>照套就行</p>
<h1 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h1><p>模数的除法 是 乘上乘法逆元</p>
<p>$(a \ mod \ p) × \ (b \ mod \ p) == a×b \ mod \ p$</p>
<p>$\frac{a\ mod\ p}{b\ mod\ p}≠\frac{a}{b}\ mod\ p$ </p>
<p>$\frac{a}{b}\ mod\ p\ =\ (a\ mod\ p)×(b^{-1}\ mod\ p)$ </p>
<p>逆元定义</p>
<blockquote>
<p>  若整数 $b$，$p$ 互质，并且对于任意的整数 $a$，如果满足 $b|a$，则存在一个整数 $x$，使得 $a/b≡a\cdot x \ (mod\ p)$，则称 $x$ 为 $b$ 的模 $p$ 乘法逆元，记为 $b^{−1} \ (mod \ p)$。</p>
<p>  $b$ 存在乘法逆元的充要条件是 $b$ 与模数 $p$ 互质。当模数 $p$ 为质数时，$b^{p−2}$ 即为 $b$ 的乘法逆元。</p>
</blockquote>
<blockquote>
<p>  百科例子：4关于1模7的乘法逆元为多少？</p>
<p>  $4X≡1 \ mod \ 7$ </p>
<p>  这个方程等价于求一个X和K，满足</p>
<p>  $4X=7K+1$</p>
<p>  其中X和K都是整数。</p>
</blockquote>
<blockquote>
<p>  <strong>费马小定理</strong>：如果 $p$ 是一个质数，而整数 $b$ 不是 $p$ 的倍数，则有$b^{p-1}≡1 \ (mod \ p)$ </p>
<p>  满足费马小定理，则有此结论： $b^{p-2}$ 就是 $b$ 的逆元</p>
</blockquote>
<blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  特别的，如果 $bx+py=1$ 即可以转换成扩展欧几里得算法来求解 $x$，即为 $b$ 的逆元</p>
</blockquote>
<p><strong>数学结论：</strong></p>
<ul>
<li><p>  $b$ 有逆元的充要条件是 $b$ 与 $p$ 互质</p>
</li>
<li><p>当 $p$ 为质数时，可用快速幂求逆元</p>
<ul>
<li><p>  $b$ 的乘法逆元为 $b^{p-2}$ ，<code>qmi(b, p - 2, p)</code></p>
</li>
<li><p>  当 $b$ 为 $p$ 的倍数时，**$b$ 的逆元不存在**， $b \cdot x%p==0$ ，$b$ 乘任意一个 $x%p$ 一定等于0</p>
</li>
</ul>
</li>
<li><p>当 $p$ 不为质数时，只能用扩展欧几里得算法求逆元</p>
<ul>
<li>当 $bx+py=1$ 时，$x$ 即为 $b$ 的逆元</li>
</ul>
</li>
</ul>
<p><strong>当 $p$ 为质数时，可以用快速幂求逆元的推导：</strong></p>
<p>$$a / b ≡ a * x \ (mod \ p)$$ </p>
<p>两边同乘 $b$ 可得 $a ≡ a * b * x \ (mod \ p)$ </p>
<p>同除 $a$ 即 $1 ≡ b * x \ (mod \ p)$ </p>
<p> $b * x ≡ 1 \ (mod \ p)$ </p>
<p>由费马小定理可知，当 $p$ 为质数时</p>
<p>$b ^ {n - 1} ≡ 1 \ (mod \ p)$ </p>
<p>拆一个 $b$ 出来可得 $b * b ^ {n - 2} ≡ 1 \ (mod \ p)$ </p>
<p>故当 $p$ 为质数时，$b$的乘法逆元 $x = b ^ {p - 2}$ </p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/878/">AcWing 875. 快速幂求逆元</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b % p == <span class="number">0</span>) <span class="comment">// b能整除p说明，b和p不互质，即 b mod p的逆元不存在</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qmi</span>(b, p<span class="number">-2</span>, p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p><strong>当 $p$ 不是质数时，用扩展欧几里得算法求逆元：</strong></p>
<p>$b$ 有逆元的充要条件是 $b$ 与 $p$ 互质，所以 $gcd(b, p) = 1$</p>
<p>假设 $b$ 的逆元为 $x$，那么有 $b * x ≡ 1 \ (mod \ p)$</p>
<p>等价： $bx + py = 1$ </p>
<p>$exgcd(b, p, x, y)$ </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) cout &lt;&lt; ((LL)x + p) % p; 当且仅当 (a,p)=<span class="number">1</span> 时有解。</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>求一元线性同余方程组</p>
<p><strong>定义：</strong></p>
<p>给定一组线性同余方程组，求出 $x$ 最小非负整数解：<br>                                                                $$x≡a_1 \ mod \ m_1 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                            $$⋮ $$<br>                                                                            $$⋮ $$<br>                                                                $$x≡a_n \ mod \ m_n$$</p>
<blockquote>
<p>  <strong>中国剩余定理：</strong></p>
<p>  设 $M=m_1 \times m_2 \times … \times m_n = \prod_{i=1}^{n}{m_i}$ ，$M_i=\frac{M}{m_i}$ 是除了<em>m</em>i以外的<em>n</em>- 1个整数的乘积，$M_i^{-1}$ 是 $M_i$ 模 $m_i$ 意义下的逆元。</p>
<p>  则方程组的通解为</p>
<p>   $x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_nM_nM_n^{-1}+kM=kM+\sum_{i=1}^{n}a_iM_iM_i^{-1},k∈Z$ </p>
<p>  在模 $M$ 的意义下，方程组只有一个解：<br>                                                                               $$x=(\sum^{n}_{i=1}a_iM_iM_i^{-1}) \ mod \ M$$</p>
<p>即：<br>                                                                                  $$x=(\sum^{n}_{i=1}a_i \frac{M}{m_i} (\frac{M}{m_i})^{-1}) \ mod \ M$$</p>
</blockquote>
<p>思路：将多个方程组合为一个方程来求解，即将两个线性同余方程合为一个，以此类推。</p>
<p>推导：</p>
<p>首先考虑前两个线性同余方程：<br>                                                                                        $$x≡a_1 \ mod \ m_1$$<br>​                                                                                        $$x≡a_2 \ mod \ m_2$$ </p>
<p>转化为：<br>                                                                                        $$x=m_1⋅k_1+a_1$$<br>                                                                                        $$x=m_2⋅k_2+a_2$$ </p>
<p>将这两个方程合并移项，可得：<br>                                                                                        $$m_1⋅k_1−m_2⋅k_2=a_2−a_1$$</p>
<p> 即：<br>                                                                                        $$m_1⋅k_1+m_2⋅(-k_2)=a_2−a_1$$</p>
<p><strong>这个方程有解必须满足：</strong><br>                                                                                        $$(a_2-a_1)\ % \ d==0$$</p>
<p>若有解，我们可以通过求<strong>线性同余方程的通解</strong>来得出<br>                                                                                        $$k_1=k_1+\frac{m_2}{d} \cdot k \ ,k∈Z$$<br>                                                                                        $$k_2=k_2+\frac{m_1}{d} \cdot k \ , k∈Z$$</p>
<p>将 $k_1$ 带回 $x=m_1 \cdot k_1 +a_1$ 得：<br>                                                                                        $$x=k_1 \cdot m_1 +a_1$$<br>                                                                                        $$x=(k_1+k \cdot \frac{m_2}{d}) \cdot m_1 + a_1$$</p>
<p>展开：<br>                                                                                        $$x=\frac{m_1m_2}{d} \cdot k+k_1m_1+a_1$$</p>
<p>$\frac{m_1m_2}{d}$ 为 $m_1$ 和 $m_2$  的最小公倍数，即：<br>                                                                                        $$x=[m_1,m_2] \cdot k+k_1m_1+a_1 \ ①$$</p>
<p>可以发现上面的方程与这方程相类似<br>                                                                                        $$x=m⋅k+a$$</p>
<p>对比发现：<br>                                                                                        $$m=[m_1,m_2]$$<br>                                                                                        $$a=k_1m_1+a_1$$</p>
<p>将得到的方程①与下一个同余方程合并，直到最后只剩一个方程时：$x=m \cdot k+a$</p>
<p>即求：<br>                                                                                        $$x \ mod \ m ≡ a$$</p>
<p>即求：<br>                                                                                        $$x=a \ mod \ m$$</p>
<p>最后直接用合并后方程的 $a$ 和 $m$ 求一个最小正整数解即可： $(a % m +m )%m$ </p>
<p>思路就是按照推导过程去实现</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/206/">AcWing 204. 表达整数的奇怪方式</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LL n, a1, a2, k1, k2, m1, m2;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; m1 &gt;&gt; a1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m2 &gt;&gt; a2;</span><br><span class="line">    LL d = <span class="built_in">exgcd</span>(m1, -m2, k1, k2); <span class="comment">// 求得 k1*m1 + k2*(-m2) = d</span></span><br><span class="line">    <span class="keyword">if</span>((a2 - a1) % d) <span class="comment">// 不能整除则无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  求出的是 k1*m1 + k2*m2 = d ，我们需要求的是右边是 a2-a1的值</span></span><br><span class="line"><span class="comment">        因为 d 与 a2-a1 是倍数，所以两边翻(a2-a1)/d倍即可，</span></span><br><span class="line"><span class="comment">        k2不需要翻倍的原因是，不需要用到</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    k1 *= (a2 - a1) / d; <span class="comment">//翻若干倍</span></span><br><span class="line">    LL t = m2 / d; <span class="comment">// k1的通解：k1=k1+m2/d*k ，k∈Z</span></span><br><span class="line">    k1 = (k1 % t + t) % t; <span class="comment">// 将k1变成最小的正整数解</span></span><br><span class="line"></span><br><span class="line">    a1+= k1 * m1; <span class="comment">// a=k1*m1+a1 得先求了a1才能求m1,不然m1值变了</span></span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">abs</span>(m1 / d * m2); <span class="comment">// m=[m1,m2] 最小公倍数数，有可能是负的，这里求一个正的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (a1 % m1 + m1) % m1 &lt;&lt; endl; <span class="comment">//结果就是x = a mod m ，但这里求一个最小正整数解</span></span><br></pre></td></tr></table></figure>





<h1 id="高斯消元解线性方程"><a href="#高斯消元解线性方程" class="headerlink" title="高斯消元解线性方程"></a>高斯消元解线性方程</h1><p>思路：</p>
<ul>
<li>枚举每一列 $c$ <ol>
<li>  找到绝对值最大的一行</li>
<li>  将该行换到最上面</li>
<li>  （倒着算）将该行该列的这个数变成 1</li>
<li>  （从上往下）将下面所有行的第 $c$ 列消成 0</li>
</ol>
</li>
<li>  判断是否有解 或 为无穷解</li>
<li>（从下往上）将上面所有行的第 $c$ 列消成 0<ul>
<li>枚举每一列<ul>
<li>  枚举每一行（倒着算）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h1><p>红线代表曼哈顿距离，绿色代表<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB">欧氏距离</a>，也就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB">直线距离</a>，而蓝色和黄色代表等价的曼哈顿距离。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF">曼哈顿</a>距离——两点在南北方向上的距离加上在东西方向上的距离，即 $d(i,j)=|x_i-x_j|+|y_i-y_j|$ 。曼哈顿距离又称为出租车距离。</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/曼哈顿距离.png" alt="曼哈顿距离" style="zoom: 67%;">

<p>曼哈顿距离包括终点本身</p>
<p><strong>都是整数</strong></p>
<h1 id="欧几里得距离"><a href="#欧几里得距离" class="headerlink" title="欧几里得距离"></a>欧几里得距离</h1><p>两点之间的距离，也称<strong>欧氏距离</strong></p>
<p>这个就是高中二维和三维坐标系所学的</p>
<p><strong>有浮点数</strong></p>
<p>二维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$$ </p>
<p>三维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}$$ </p>
<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="Ⅰ-O-N-2"><a href="#Ⅰ-O-N-2" class="headerlink" title="Ⅰ $O(N^2)$"></a>Ⅰ $O(N^2)$</h2><p>10万组询问，$1≤m≤n≤2000$，$p=10^9 + 7$</p>
<p>$C_n^m=C_{n-1}^{m}+C_{n-1}^{m-1}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="comment">// 从i个中选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 选j个</span></span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>; <span class="comment">// 从i个中选0个，方案数为1</span></span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DP预处理出$C_{0 … N - 1}^{0 … N - 1}$的所有情况</p>
<h2 id="Ⅱ-O-NlogN"><a href="#Ⅱ-O-NlogN" class="headerlink" title="Ⅱ $O(NlogN)$"></a>Ⅱ $O(NlogN)$</h2><p>1万组询问，$1≤m≤n≤1e5$，$p=10^9 + 7$</p>
<p>$$C_{n}^{m}=\frac{n!}{m!(n-m)!}$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        t = (LL)t * t % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C_&#123;a&#125;^&#123;b&#125; resul</span></span><br><span class="line">cout &lt;&lt; (LL)fact[a] * infact[a - b] % mod * infact[b] % mod &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>预处理出所有情况</p>
<h2 id="Ⅲ-Lucas定理-O-p-cdot-log-pN-cdot-log-p"><a href="#Ⅲ-Lucas定理-O-p-cdot-log-pN-cdot-log-p" class="headerlink" title="Ⅲ Lucas定理$O(p \cdot log_pN \cdot log\ p )$"></a>Ⅲ Lucas定理$O(p \cdot log_pN \cdot log\ p )$</h2><p>20组(少量)询问，$1≤m≤n≤10^{18}$，$1≤p≤10^5$</p>
<p>$$C_{n}^{m}≡C_{n % p}^{m % p} \cdot C_{n / p}^{m / p} \ (mod \ p)$$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/21/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/21/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/" itemprop="url">二分图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-21T16:58:03+08:00">
                2021-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><img src="https://bkimg.cdn.bcebos.com/pic/7a899e510fb30f24a3ac24f6c195d143ad4b0315?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==" style="zoom:67%;">
![二分图](http://duegin.gitee.io/pic/pictures/3.搜索与图论/二分图.png)

<h1 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h1><p>时间复杂度是 $O(n+m)$ ， $n$ 表示点数， $m$ 表示边数</p>
<p>思路：</p>
<ul>
<li>初始化各点为未染色</li>
<li>枚举每个点<ul>
<li>if 该点 a 未被染色<ul>
<li>进行染色并判断是否发生矛盾<br>而这里是采用递归染色， dfs 的思路是：</li>
</ul>
</li>
</ul>
</li>
<li>先将当前结点 $u$ 染色</li>
<li>遍历点 $u$ 的所有邻接点<ul>
<li>if 该点未染色<ul>
<li>dfs 染色，且判断他的邻接点及其后的点染色是否发生矛盾</li>
</ul>
</li>
<li>else if 如果该点已经被染色了，那判断该点是否与点 $u$ 颜色相同</li>
</ul>
</li>
</ul>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/862/">AcWing 860. 染色法判定二分图</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 将点 u 染成c号色，并将点 u 下的点按二分图规则染色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">//染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>) <span class="comment">// 点j未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="comment">// 如果在此过程中有一个地方发生矛盾，则肯定不是二分图</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果该点已经被染色了，且与点u颜色相同，那肯定有矛盾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断邻接表是否为二分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color); <span class="comment">//初始化染色数组</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 枚举每个点，防止图不是连通图</span></span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>) <span class="comment">// 如果未被染色，则深度优先染色</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>)) <span class="comment">// 进行染色且返回是否染色没发生矛盾</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>时间复杂度是 $O(nm)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/863/">AcWing 861. 二分图的最大匹配</a></p>
<p>按照 y 总的思路，将左半部集合看成是男生，右半部看成女生，逐一给他们牵红线，如果遇到喜欢同一个女生，则看看上家有没有其他备胎可选</p>
<p>核心还是递归</p>
<p>思路：</p>
<ul>
<li>初始化所有女孩的配对都为 0</li>
<li>遍历所有男生<ul>
<li>重置每个女生配对预选人</li>
<li>（递归）寻找该男生的配对，并判断能否找到心仪对象<br>递归配对思路：</li>
</ul>
</li>
<li>遍历该男生心仪女孩<ul>
<li>如果未被遍历，则设置为已遍历<ul>
<li>如果如果女孩j没有男朋友，或者她原来的男朋友能够匹配其它喜欢的女孩。配对成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7y35ngyr5g311v0j67jy.gif" alt="匈牙利算法"></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合（左集合）中的点数，n2表示第二个集合（右集合）中的点数</span></span><br><span class="line">                <span class="comment">// n1的点作为槽，n2的点作为邻接点</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];    <span class="comment">// 存储右集合中的每个点当前匹配的左集合中的点是哪个</span></span><br><span class="line">                 <span class="comment">// match[j]=a,表示女孩j的现有配对男友是a</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示模拟匹配时，右集合中的每个点是否已经被遍历过</span></span><br><span class="line">                <span class="comment">// st[]数组我称为临时预定数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找点x的匹配值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历自己喜欢的女孩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 如果在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果该女生未被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果女孩j没有男友，或者她原来的男友能够预定其它喜欢的女孩。配对成功</span></span><br><span class="line">            <span class="comment">// 这里 match[j]就是女生 j 的男友</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) <span class="comment">// 如果他不在已确认的点中 或 这个点能找到下家</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己中意的全部都被预定了。配对失败。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历所有男生</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ ) <span class="comment">// 遍历左集合的每一个点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匈牙利算法的优势：</p>
<p>匈牙利算法中，一个有伴侣的人，无论男女，<strong>不会重新变成单身狗</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/20/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/20/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" itemprop="url">最小生成树汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-20T11:58:03+08:00">
                2021-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><img src="http://duegin.gitee.io/pic/pictures/3.搜索与图论/最小生成树.png" alt="最小生成树" style="zoom:67%;">



<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eb41177d1/">动画思路</a></p>
<h1 id="朴素Prim算法"><a href="#朴素Prim算法" class="headerlink" title="朴素Prim算法"></a>朴素Prim算法</h1><p>稠密图</p>
<p>时间复杂度是 $O(n^2+m)$ ， $n$ 表示点数，$m$ 表示边数</p>
<p><strong>思路</strong>（与dijkstra算法相似）：</p>
<ul>
<li>  所有点到连通块（集合）的距离初始化为正无穷，即所有点初始时都不在连通块中</li>
<li>  选取任意一个点作为连通块中的一个点</li>
<li>迭代n次<ul>
<li>  每次找到 不在集合中 距离最小 的点 t（连通块是当前生成树）</li>
<li>  用 t 更新其他点的距离到连通块的距离</li>
<li>  把 t 加到集合中</li>
</ul>
</li>
</ul>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];	<span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];	<span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];		<span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="comment">// 迭代n次（加入n个点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找与i直接联通的边最小值的点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">// 这里j下标对应g[][]</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">// 这里一定会更新t的</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">//如果最短的距离是INF那说明无法生成最小树了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t]; <span class="comment">// 先累加，因为如果先更新点t到其他点的距离，遇上负环的话，会把自己更新的更小</span></span><br><span class="line">        <span class="comment">// 把点加到连通块</span></span><br><span class="line">        st[t] = <span class="literal">true</span>; </span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 更新c点t到其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>稀疏图</p>
<p>时间复杂度是 $O(mlogm) $， $n$ 表示点数，$m$ 表示边数</p>
<p><strong>思路</strong>（类似并查集）：</p>
<ul>
<li>  将所有边按权重从小到大排序</li>
<li>枚举每条边a,b 权重c<ul>
<li>if a,b不连通<ul>
<li>  将这条边加入连通块（集合）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>具体可以参考动画思路，先按边的权重排序，如果点 a,b 不在集合中，则将这条边加入集合中，即将 点 a 的祖宗节点指向 b 即可（a 和 b 掉转也行），这样就能将 a 与 b 归为一个集合，重复上诉操作，而这样是不会有环的，因为每次只会加入一个点，而且已经加入的点是不会再更新的</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> fa[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="comment">// 重载 小于号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;e1)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e1.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作, 查找x的祖宗结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) fa[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = e[i].a, b = e[i].b, w = e[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            fa[a] = b; <span class="comment">// 归到一个集合中</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/20/%E7%AE%97%E6%B3%95/1.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/20/%E7%AE%97%E6%B3%95/1.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%92%8C%20%E5%B7%AE%E5%88%86/" itemprop="url">前缀和 和 差分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-20T00:13:17+08:00">
                2021-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基础算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>求<code>[l, r]</code>之和 $\sum_{i=l}^{r}{a_i}=a_l+a_{l+1}+…+a_r$</p>
<p><strong>结论：</strong>$$S_{lr} = S_r - S_{l-1}$$</p>
<p>推导：</p>
<blockquote>
<p>  $$S_r=a_1+a_2+…+a_{l-1}+a_l+…+a_r$$</p>
<p>  $$S_{l-1}=a_1+a_2+…+a_{l-1}$$</p>
<p>  即：</p>
<p>  $$S = S_r - S_{l-1}$$</p>
<p>  $$S = a_l+a_{l+1}+…+a_r$$</p>
</blockquote>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>求<code>(x1, y1) ~ (x2, y2)</code>前缀和</p>
<blockquote>
<p>  初始化的二维前缀和：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">       s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>结论：</strong>$$S=S-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}$$</p>
<p>即：<code>s = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p>
<img src="http://duegin.gitee.io/pic/pictures/1.基础算法/二维子矩阵前缀和.png" alt="二维子矩阵前缀和" style="zoom:70%;">



<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分数组前n项和即为前缀和，其实就是前缀和的逆运算</p>
<h2 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h2><p><strong>给区间$[l, r]$中的每个数加上c：</strong>（例题：ACWing 797.差分）</p>
<p><strong>结论：</strong><code>b[l] += c, b[r + 1] -= c</code></p>
<p>只要<code>b[l]</code>加上 c，则 <code>l</code> 后面的前 n 项和都加上 c 了，所以要在 <code>b[r + 1]</code> 减上 c ，才能持 0</p>
<p>设 $a_n$ 为 $b_n$ 的前n项和，则</p>
<p>既然差分是前缀和的逆运算，那么可以用上诉结论来逆运算出<code>b[]</code> </p>
<p>即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	b[i]+=c;</span><br><span class="line">    b[i+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出时，只需要对<code>b[]</code> 用一维前缀和公式即可</p>
<h2 id="二维差分数组"><a href="#二维差分数组" class="headerlink" title="二维差分数组"></a>二维差分数组</h2><p>给以<code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵中的所有元素加上c：<br><strong>结论：</strong><code>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</code></p>
<p>设 <code>a[][]</code> 为 <code>b[][]</code> 的前缀和</p>
<img src="http://duegin.gitee.io/pic/pictures/1.基础算法/二维差分矩阵.png" alt="二维差分矩阵" style="zoom:67%;">

<p>即为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化可以为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br></pre></td></tr></table></figure>

<p>输出结果，同样是二维前缀和</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/17/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/17/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" itemprop="url">拓扑排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-17T00:35:03+08:00">
                2021-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">搜索与图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>时间复杂度 $O(n+m)$ ， $n$ 表示点数，$m$ 表示边数<br>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">AcWing 848. 有向图的拓扑序列</a><br>思路：（宽搜 + 删点）</p>
<ul>
<li>（队列初始化）先让所有入度为 0 的点入队</li>
<li>while(队列非空)<ul>
<li>获取队头并弹出</li>
<li>更新该点的邻接点的入度<ul>
<li>将入度为 0 的点入队</li>
</ul>
</li>
</ul>
</li>
<li>如果所有点都入过队了，说明存在拓扑序列；否则不存在拓扑序列。</li>
</ul>
<p>最好用模拟队列实现，因为方便</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[N];<span class="comment">// 结点的入度</span></span><br><span class="line"><span class="keyword">int</span> que[N]; <span class="comment">// 模拟队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽搜思想 + 删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fr = <span class="number">0</span>, re = <span class="number">-1</span>; <span class="comment">// 还没加进去元素时，队尾设为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            que[++re] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fr &lt;= re)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = que[fr++]; <span class="comment">// 获取队头并弹出</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 更新删除 t 结点后所有点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                que[++re] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> re == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">&gt;</a>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Rin.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DueGin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DueGin</span>

  
</div>







<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
