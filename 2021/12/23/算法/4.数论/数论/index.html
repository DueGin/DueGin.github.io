<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%85%AB%E5%8D%A6%E5%9B%BE.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="c++,算法,数论," />










<meta name="description" content="数论质数方法：  试除法判定质数 试除法分解质因数 埃氏筛法求素数 线性筛法求素数  试除法判定质数时间复杂度 $O(\sqrt{n})$ 模板题：AcWing 866. 试除法判定质数 模版： 123456789&#x2F;&#x2F; 判断 x 是否为质数bool is_prime(int x)&amp;#123;    if (x &lt; 2) return false; &#x2F;&#x2F; 判断1和0    for (int i">
<meta property="og:type" content="article">
<meta property="og:title" content="数论">
<meta property="og:url" content="https://duegin.github.io/2021/12/23/%E7%AE%97%E6%B3%95/4.%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/index.html">
<meta property="og:site_name" content="DueGin">
<meta property="og:description" content="数论质数方法：  试除法判定质数 试除法分解质因数 埃氏筛法求素数 线性筛法求素数  试除法判定质数时间复杂度 $O(\sqrt{n})$ 模板题：AcWing 866. 试除法判定质数 模版： 123456789&#x2F;&#x2F; 判断 x 是否为质数bool is_prime(int x)&amp;#123;    if (x &lt; 2) return false; &#x2F;&#x2F; 判断1和0    for (int i">
<meta property="og:locale">
<meta property="og:image" content="http://duegin.gitee.io/pic/pictures/4.数论/线性筛法例子.png">
<meta property="og:image" content="http://duegin.gitee.io/pic/pictures/4.数论/容斥原理.png">
<meta property="og:image" content="http://duegin.gitee.io/pic/pictures/4.数论/曼哈顿距离.png">
<meta property="article:published_time" content="2021-12-22T16:39:17.000Z">
<meta property="article:modified_time" content="2022-04-08T16:27:41.749Z">
<meta property="article:author" content="DueGin">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://duegin.gitee.io/pic/pictures/4.数论/线性筛法例子.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://duegin.github.io/2021/12/23/算法/4.数论/数论/"/>





  <title>数论 | DueGin</title>
  








<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DueGin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
    
  
  

  <article class="post post-type-normal true" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://duegin.github.io/2021/12/23/%E7%AE%97%E6%B3%95/4.%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Rin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DueGin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数论</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-23T00:39:17+08:00">
                2021-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>方法：</p>
<ul>
<li>试除法判定质数</li>
<li>试除法分解质因数</li>
<li>埃氏筛法求素数</li>
<li>线性筛法求素数</li>
</ul>
<h2 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h2><p>时间复杂度 $O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/868/">AcWing 866. 试除法判定质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 x 是否为质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断1和0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">//从1～sqrt(x)里找即可</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只需遍历到 $\sqrt{x}$ 的原因是：<br>一个数的因数都是<strong>成对存在的</strong>，即：<br>$d&lt;={x}/{d}$， $d^2&lt;=x$，$d&lt;=\sqrt{x}$</p>
<p>例如12的因数有3和4，2 和6，所以我们可以只枚举较小的那一个，即 $\sqrt{x}$ ，假设较小的为d，较大的为 x/d<br>其实我认为：$x$ 质因数边界就是 $\sqrt{x}$</p>
</blockquote>
<h2 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h2><p>时间复杂度：$O(\sqrt{n})$</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/869/">AcWing 867. 分解质因数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 级数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                cnt ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#4">埃拉托斯特尼筛法</a>，简称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%83%E6%B0%8F%E7%AD%9B/5677377">埃氏筛</a>或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于 $\sqrt{x}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>要得到自然数n以内的全部素数，必须把不大于 $\sqrt{n}$ 的所有素数的倍数剔除，剩下的就是素数。</p>
<p>时间复杂度 $O(nloglogn)$</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有质数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 筛选 2～n 的所有数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i; <span class="comment">// 将 i 存入质数数组中</span></span><br><span class="line">        <span class="comment">// 质数的倍数绝对不是质数，把所有质数的倍数全部丢弃</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) <span class="comment">// 将i的所有倍数筛掉，j就是几倍，而 n/i则是i的最大倍数，小学数学</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  给出要筛数值的范围n，找出以内的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个质数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个质数5筛，把5留下，把5的倍数剔除掉；不断重复下去……</p>
</blockquote>
<h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>线性筛法，也叫欧拉筛法，是在埃氏筛法的基础上做出优化，我们发现这里面似乎会对某些数标记了很多次其为合数，而线性筛法利用其最小质因数来筛掉合数，每次只标记一次</p>
<p>时间复杂度 $O(n)$ ，数据量小于1e7的情况下，线性筛法和埃氏筛法差不多，数据量大于1e7则线性筛法比埃氏筛法快一倍</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 用最小质因子去筛合数 primes[j] * i</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果 i 是合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if(i%prime[j]==0) break;</code> 这句代码保证了每个数最多被筛一次，将时间复杂度降到了线性。</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/线性筛法例子.png" alt="线性筛法例子" style="zoom:75%;">

<p>例如，$i=6$ 时，第一个素数是2，能整除，筛掉12后就 break；至于第二个素数3，6x3中的最小素因数肯定是素数2，所以它要到 $i=9$，素数取2时才被筛掉。</p>
<ol>
<li><p>  当 <code>i % primes[j] != 0</code> 时，说明此时遍历到的 <code>primes[j]</code> 不是 <code>i</code> 的质因子，那么只可能是此时的 <code>primes[j] * i</code> 的最小质因子，所以 <code>primes[j] * i</code> 的最小质因子就是 <code>primes[j]</code> </p>
</li>
<li><p>  当有 <code>i % primes[j] == 0</code> 时，说明 <code>i</code> 的最小质因子是 <code>primes[j]</code> ， 因此 <code>primes[j] * i</code> 的最小质因子也就应该是 <code>prime[j]</code>，之后接着用 <code>st[primes[j + 1] * i] = true</code> 去筛合数时，就不是用最小质因子去更新了，因为 <code>i</code> 有最小质因子 <code>primes[j]&lt;primes[j+1]</code>，此时的 <code>primes[j+1]</code>不是 <code>primes[j+1]*i</code> 的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</p>
</li>
</ol>
<blockquote>
<p>补充：一个数乘上合数肯定是合数，所以只需要让遍历到的数 i 乘上其最小质因数 <code>prime[j]</code> 即可，这样的话乘上后的数必是合数，且有质因数是 <code>prime[j]</code></p>
</blockquote>
<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>方法：</p>
<ul>
<li>试除法求所有约数</li>
<li>约数个数 和 约数之和</li>
<li>欧几里得算法</li>
</ul>
<p>n 与 1～n 的约数互为质数的个数：</p>
<ul>
<li>朴素求欧拉函数</li>
<li>筛法求欧拉函数</li>
</ul>
<h2 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h2><p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/871/">AcWing 869. 试除法求约数</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回升序的x所有质数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  因为约数都是成对存在的，所以只需要遍历到 $\sqrt{x}$ 即可，具体看<strong>试除法求质数</strong></p>
</blockquote>
<blockquote>
<p>  第9行：防止当约数重复加入，如25=5*5</p>
</blockquote>
<h2 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86/4926961">约数个数定理</a> </p>
<p>乘法原理，组合数学</p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>约数个数： $(c_1 + 1) \times (c_2 + 1) \times … \times (c_k + 1)$ </p>
<p>可以发现：约数个数和质因数是啥无关</p>
<blockquote>
<p>  百科例题：正整数 378000 共有多少个正约数？</p>
<p>  解：将 378000 分解质因数$378000=2^4×3^3×5^3×7^1$</p>
<p>  由约数个数定理可知378000共有正约数$(4+1)×(3+1)×(3+1)×(1+1)=160$个。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/872/">AcWing 870. 约数个数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h : m) res *= (h.second + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  这里的扫尾是因为，有可能最后除到 $x$ 是质数了，比如 7 或14 最后只能由扫尾加入 7 这个质因数</p>
</blockquote>
<h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428">约数和定理</a> </p>
<p>模板题： <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/873/">AcWing 871. 约数之和</a> </p>
<p><strong>数学结论：</strong></p>
<p>$N$ 是某个数， $p_i$ 是质因数， $c_i$ 是质因数的级数</p>
<p>如果 $N = p_1^{c_1} \times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>约数之和： $(p_1^0 + p_1^1 + … + p_1^{c_1}) \times … \times (p_k^0 + p_k^1 + … + p_k^{c_k})$ </p>
<blockquote>
<p>  百科例题：正整数360的所有正约数的和是多少？</p>
<p>  解：将360分解质因数可得</p>
<p>  $360=2^3<em>3^2</em>5^1$</p>
<p>  由约数和定理可知，360所有正约数的和为</p>
<p>  $(2^0+2^1+2^2+2^3)×(3^0+3^1+3^2)×(5^0+5^1)=(1+2+4+8)(1+3+9)(1+5)=15×13×6=1170$</p>
<p>  可知360的约数有1、2、3、4、5、6、8、9、10、12、15、18、</p>
<p>  20、24、30、36、40、45、60、72、90、120、180、360；则它们的和为</p>
<p>  1+2+3+4+5+6+8+9+10+12+15+18+20+24+30+36+40+45+60+72+90+120+180+360=1170</p>
</blockquote>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// first为质因数，second为级数</span></span><br><span class="line"><span class="comment">//试除法求约数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divisors_num</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x/i; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) m[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> h : m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p = h.first, c = h.second; <span class="comment">// p是底数，c是级数</span></span><br><span class="line">    LL t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c--) t = t * p + <span class="number">1</span>; <span class="comment">// pi^(0~ak)之和，也可以用等比求和</span></span><br><span class="line">    res *= t; <span class="comment">// 所有pi相乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>原理：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a></p>
<p>也叫辗转相除法</p>
<blockquote>
<p>  百科例子：</p>
<p>  假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：</p>
<p>  1997 / 615 = 3 (余 152)</p>
<p>  615 / 152 = 4(余7)</p>
<p>  152 / 7 = 21(余5)</p>
<p>  7 / 5 = 1 (余2)</p>
<p>  5 / 2 = 2 (余1)</p>
<p>  2 / 1 = 2 (余0)</p>
<p>  至此，最大公约数为1</p>
<p>  以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/874/">AcWing 872. 最大公约数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  这里a 和 b无论谁大都可用，我试过了</p>
</blockquote>
<h3 id="Stein算法"><a href="#Stein算法" class="headerlink" title="Stein算法"></a>Stein算法</h3><p>针对欧几里德算法在对大整数进行运算时，需要试商导致增加运算时间的缺陷，还有一种算法可对其优化：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Stein%E7%AE%97%E6%B3%95"><strong>Stein算法</strong></a> </p>
<h3 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%B3%95/10277459">更相减损法</a>有点类似于求最大公约数的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Stein%E7%AE%97%E6%B3%95">Stein算法</a>。在更相减损法中，若两个是偶数则同除以2，结果乘以2。如果增加一个判断，若为一奇一偶则偶数除以2，结果不变，若为两个奇数才相减，这样就变成了计算大整数最大公约数的非常好的一个算法，Stein算法。</p>
<p>第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。</p>
<p>第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。</p>
<p>则第一步中约掉的若干个2的积与第二步中等数的乘积就是所求的最大公约数。</p>
<blockquote>
<p>  百科例子：</p>
<p>  解：由于260和104均为偶数，首先用 2 约简得到 130 和 52，再用 2 约简得到 65 和 26。</p>
<p>  此时 65 是奇数而 26 不是奇数，故把 65 和 26 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%97%E8%BD%AC%E7%9B%B8%E5%87%8F/7529647">辗转相减</a>：</p>
<p>  65-26=39</p>
<p>  39-26=13</p>
<p>  26-13=13</p>
<p>  所以，260 与 104 的最大公约数等于 13 乘以第一步中约掉的两个2，即13<em>2</em>2=52。</p>
</blockquote>
<h3 id="区间最大公约数"><a href="#区间最大公约数" class="headerlink" title="区间最大公约数"></a>区间最大公约数</h3><p>同样用到了更相减损术</p>
<p>即：<code>t[]=&#123;a, b, c&#125;</code></p>
<p>$$<br>gcd(t)=&gt;gcd(a,b-a,c-b)=gcd(a,\ gcd(b-a,c-b))<br>$$<br>这里需要用差分来预处理再倒着 gcd 一遍即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n], s[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = s[i] - s[i - <span class="number">1</span>]; <span class="comment">// 差分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) res = <span class="built_in">gcd</span>(res, a[i]); <span class="comment">//gcd(a, b - a, c - b, d - c, ...)</span></span><br></pre></td></tr></table></figure>



<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>定理：</p>
<p>$$<br>(a,b) \times [a,b]=a \times b<br>$$</p>
<p>即需要用到 $gcd(a,b)$ 先求出最大公约数，再用两数之积除以 $d$</p>
<h2 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h2><p>在数论，对正整数 n，欧拉函数是小于 n 的正整数中与 n <a href="%E4%BA%92%E8%B4%A8%E6%98%AF%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E6%95%B4%E6%95%B0%E3%80%82%E5%85%AC%E7%BA%A6%E6%95%B0%E5%8F%AA%E6%9C%891%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%8F%AB%E5%81%9A%E4%BA%92%E8%B4%A8%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8C%E5%90%8E%E8%80%85%E6%98%AF%E5%89%8D%E8%80%85%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E3%80%82">^互质</a>的数的数目。</p>
<p>原理： <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/1944850">欧拉函数</a> 容斥原理</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/容斥原理.png" alt="容斥原理" style="zoom:61%;">

<p>N的质因数分解： $N=p_1^{c_1}\times p_2^{c_2} \times … \times p_k^{c_k}$ </p>
<p>与 N 互质的数的个数<strong>结论</strong>：</p>
<p> $φ(N)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ </p>
<p>$\ \ \ \ \ \ \ \ \ \ =N \times \frac{p_1-1}{p_1} \times \frac{p_2-1}{p_2}…\frac{p_k-1}{p_k}$ </p>
<p>可以发现：<strong>欧拉函数与质因数的级数无关</strong> </p>
<h3 id="朴素求法"><a href="#朴素求法" class="headerlink" title="朴素求法"></a>朴素求法</h3><p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/875/">AcWing 873. 欧拉函数</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) <span class="comment">// 试除法求质因数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除后乘，防止溢出</span></span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>这个思路是利用了线性筛法来求欧拉函数，代码也在线性筛法的基础上作出了小修改，在求质因数的时候，用其最小质因数去更新其欧拉函数</p>
<p>思路（类似DP）：</p>
<ul>
<li>  先写出线性筛法模板</li>
<li>  多开一个 $euler[N]$ 数组存每个数的欧拉函数</li>
<li>分情况<ul>
<li>被筛掉的情况<ul>
<li>  被筛掉说明是质数，那他的欧拉函数就是 $i-1$ </li>
</ul>
</li>
<li>筛选时的情况<ul>
<li>  $primes[j]$ 为 $primes[j] \times i$ 的最小质因数</li>
<li><code>i % p[j] == 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times primes[j]$ </li>
</ul>
</li>
<li><code>i % p[j] != 0</code> 的情况<ul>
<li>  $φ(primes[j] \times i)=φ(i) \times (primes[j]−1)$ </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面 $primes[j]$ 用 $p[j]$ 表示</p>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>   $φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ 是 $i$ 的一个质因子，而且欧拉函数与质因子个数无关，所以在算 $p[j]\times i$ 分解质因子也是 $p_1 -&gt; p_k$ </p>
<p>  因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) $ </p>
<p>  即： $φ(p[j]\times i)=p[j]\times φ(i) $ </p>
</blockquote>
<p>上面 <code>i % p[j] == 0</code> 的情况：</p>
<blockquote>
<p>$φ(i)=i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k})$ ，因为 $p[j]$ <strong>不是</strong> $i$ 的一个质因子，所以 $p[j]\times i$ 与 $i$ 的质因子的区别就是前者比后者多一个 $p[j]$ </p>
<p>因此 $ φ(p[j]\times i)=p[j]\times i \times (1-\frac{1}{p_1}) \times (1-\frac{1}{p_2})…(1-\frac{1}{p_k}) \times (1-\frac{1}{p_j})$  </p>
<p>即： $φ(p[j]\times i)=p[j]\times φ(i) \times (1-\frac{1}{p_j})$ </p>
<p>即： $φ(p[j] \times i)=φ(i) \times (p[j]−1)$ </p>
</blockquote>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/876/">AcWing 874. 筛法求欧拉函数</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 线性筛法求欧拉函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>; <span class="comment">// 质数的话，肯定是前面的数，除了0以外互质的数只有1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ ) <span class="comment">// 遍历质数，用最小质因数筛掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i; <span class="comment">// 质数*i </span></span><br><span class="line">            st[t] = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// 用最小质因数去更新其欧拉函数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">// i % p[j] == 0的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j]; <span class="comment">// 直接乘上其最小质因数的欧拉函数即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i % p[j] != 0的情况</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">// 这里是化简后的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  当 $i$ 未被标记时，即 $i$ 为质数，那肯定是前面的数，除了0以外只有1是互质的数</p>
</blockquote>
<p>背过吧…</p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>求 $a^k$  mod  $p$，时间复杂度 $O(logk)$ </p>
<p><strong>数学结论：</strong></p>
<p>传统方法是直接将 $a$ 乘 $b$ 次，但是算法复杂度是 $O(b)$ ，如果遇到 $b$ 很大的情况就很慢。</p>
<p>其实就是把幂转成二进制，然后来算</p>
<p>$$a^k=a^{2 \frac{k}{2}}=(a^2)^{\frac{k}{2}}$$ </p>
<p>如果把 k 转成二进制数 $(k)_{10}=(…bcd)_2$ </p>
<p>那么：<br> $$a^k=a^{d \  \cdot \ 2^0 + c \ \cdot \ 2^1 + b\ \cdot \ 2^2+ \ …}$$ </p>
<p> $$a^k=a^{d \  \cdot \ 2^0} \cdot a^{c \  \cdot \ 2^1} \cdot a^{b \  \cdot \ 2^3} \ …$$ </p>
<p>可以发现其实就是将幂拆成用二进制表示幂来算</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/877/">AcWing 875. 快速幂</a> </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a^k%p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>,t = a;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) <span class="comment">// 取二进制个位</span></span><br><span class="line">            res = (LL)res * t % p; <span class="comment">//  把每一项乘起来</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">// k把个位去掉（右移一位）</span></span><br><span class="line">        t = (LL)t * t % p; <span class="comment">// 这个就是每一次的(a^2)的级数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  例子：</p>
<p>  求$5^{11}$</p>
<p>   $$5^{11}=5^{(1011)_2}$$ </p>
<p>   ​       $$=5^{2^3+2^1+2^0}$$ </p>
<p>  ​       $$=5^{2^3} \ \cdot \ 5^{2^1} \ \cdot \ 5^{2^0}$$ </p>
<p>  ​       $$=5^{8} \ \ \cdot \ 5^{2} \ \ \cdot \ 5^{1}$$ </p>
</blockquote>
<p>如此可以发现，与幂的二进制数上的每一位有关</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p> 给定一对正整数 a,b，求出一组 x,y，使其满足：</p>
<p> $$ax+by=gcd(a,b)$$</p>
<blockquote>
<p>贝祖定理：<br>​有一个线性不定方程<br>$ax+by=c$</p>
<p>若此方程有解，那么<br>$c=k·(a,b), k∈Z^+$ </p>
</blockquote>
<p>公式推导：</p>
<p>当 $b=0$ 时 $ax+by=a$ 故而 $x=1,y=0$，</p>
<p>当 $b≠0$ 时，因为<br>$$<br>gcd(a,b)=gcd(b,a%b)<br>$$</p>
<p>而<br>$$<br>bx′+(a%b)y′=gcd(b,a%b)<br>$$</p>
<p>$$<br>bx′+(a−⌊a/b⌋\times b)y′=gcd(b,a%b)<br>$$</p>
<p>$$<br>ay′+b(x′−⌊a/b⌋\times y′)=gcd(b,a%b)=gcd(a,b)<br>$$</p>
<p>故而求得<strong>通解</strong>：<br>$$<br>x=y′,y=x′−⌊a/b⌋\times y′<br>$$</p>
<p>因此可以采取递归算法 先求出下一层的 $x′$ 和 $y′$ 再利用上述公式回代即可</p>
<p>递归边界：当 $b=0$ 时，$(a,b)=a,x=1,y∈Z$</p>
<blockquote>
<p>特别的，用扩展欧几里得算法还可以求出乘法逆元。<br>$$<br>ax≡1mod \ p<br>$$</p>
<p>$$<br>ax+py=1<br>$$</p>
<p>当且仅当 $gcd(a,p)=1$ 时有解。</p>
</blockquote>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/879/">AcWing 877. 扩展欧几里得算法</a></p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// 返回值是 a 和 b 的最大公约数，即: gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="comment">// 这是其中一组解</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>; <span class="comment">// 边界，当b=0时，手算出来的边界，a*x + 0*y = gcd(a, 0) = a</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">// 先求出下一层递归的 y = x&#x27; 和 x = y&#x27;</span></span><br><span class="line">    y -= (a / b) * x; <span class="comment">// y=x&#x27;−⌊a/b⌋*y&#x27;，这里的x&#x27;其实就是下一层递归的x，y&#x27;是下一层的y，因为上面交叉传了</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h2><blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  对任何整数 $a$、$b$ 和它们的最大公约数 $d$ ，满足：</p>
<p>  ​                                                                $$ax+by=d$$</p>
<p>  若$a$, $b$是整数，且 $gcd(a,b)=d$，那么对于任意的整数 $x$, $y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$, $y$，使得$ax+by=d$ 成立。</p>
</blockquote>
<p>当算一个线性同余方程 $ax_0+by_0=d$ 的通解时，我们可以发现 $a(x-\frac{b}{d})+b(y+\frac{a}{d})=d$ 为其中一组解</p>
<p>即其通解为：</p>
<p>​                                                                                        $$x=x_0-\frac{b}{d} \cdot k \ ,k∈Z$$</p>
<p>​                                                                                         $$y=y_0+\frac{a}{d} \cdot k \ , k∈Z$$</p>
<p>给定 $a$, $b$, $p$，求出 $x$ 使其满足</p>
<p>​                                                                        $$a \cdot x≡b \ mod \ p$$</p>
<p> 这个方程可以写为</p>
<p>​                                                                         $ax=py+b$  ，  将 $y = -y$ </p>
<p>即： $ax+py=b$</p>
<p>要使该方程有解，则满足</p>
<p>​                                                                        $$b=k \cdot gcd(a,p),k∈Z$$</p>
<p>用扩展欧几里得算法求出 $ax+py=(a,p)$ 的 $x$ 的解之后，再将 $x$ 乘上 $\frac{b}{(a,p)}$ 即可。</p>
<p>为什么要翻倍，因为我们需要求的是 $ax+py=b$ ，而 $(a,p)$ 是 $b$ 的倍数，所以两边同时翻倍即可</p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/880/">AcWing 878. 线性同余方程</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// b不是d的倍数则无解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * b / d % p; <span class="comment">// 扩大b/d倍</span></span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exgcd()</code>照套就行</p>
<h1 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h1><p>模数的除法 是 乘上乘法逆元</p>
<p>$(a \ mod \ p) × \ (b \ mod \ p) == a×b \ mod \ p$</p>
<p>$\frac{a\ mod\ p}{b\ mod\ p}≠\frac{a}{b}\ mod\ p$ </p>
<p>$\frac{a}{b}\ mod\ p\ =\ (a\ mod\ p)×(b^{-1}\ mod\ p)$ </p>
<p>逆元定义</p>
<blockquote>
<p>  若整数 $b$，$p$ 互质，并且对于任意的整数 $a$，如果满足 $b|a$，则存在一个整数 $x$，使得 $a/b≡a\cdot x \ (mod\ p)$，则称 $x$ 为 $b$ 的模 $p$ 乘法逆元，记为 $b^{−1} \ (mod \ p)$。</p>
<p>  $b$ 存在乘法逆元的充要条件是 $b$ 与模数 $p$ 互质。当模数 $p$ 为质数时，$b^{p−2}$ 即为 $b$ 的乘法逆元。</p>
</blockquote>
<blockquote>
<p>  百科例子：4关于1模7的乘法逆元为多少？</p>
<p>  $4X≡1 \ mod \ 7$ </p>
<p>  这个方程等价于求一个X和K，满足</p>
<p>  $4X=7K+1$</p>
<p>  其中X和K都是整数。</p>
</blockquote>
<blockquote>
<p>  <strong>费马小定理</strong>：如果 $p$ 是一个质数，而整数 $b$ 不是 $p$ 的倍数，则有$b^{p-1}≡1 \ (mod \ p)$ </p>
<p>  满足费马小定理，则有此结论： $b^{p-2}$ 就是 $b$ 的逆元</p>
</blockquote>
<blockquote>
<p>  <strong>裴蜀定理</strong>：</p>
<p>  特别的，如果 $bx+py=1$ 即可以转换成扩展欧几里得算法来求解 $x$，即为 $b$ 的逆元</p>
</blockquote>
<p><strong>数学结论：</strong></p>
<ul>
<li><p>  $b$ 有逆元的充要条件是 $b$ 与 $p$ 互质</p>
</li>
<li><p>当 $p$ 为质数时，可用快速幂求逆元</p>
<ul>
<li><p>  $b$ 的乘法逆元为 $b^{p-2}$ ，<code>qmi(b, p - 2, p)</code></p>
</li>
<li><p>  当 $b$ 为 $p$ 的倍数时，**$b$ 的逆元不存在**， $b \cdot x%p==0$ ，$b$ 乘任意一个 $x%p$ 一定等于0</p>
</li>
</ul>
</li>
<li><p>当 $p$ 不为质数时，只能用扩展欧几里得算法求逆元</p>
<ul>
<li>当 $bx+py=1$ 时，$x$ 即为 $b$ 的逆元</li>
</ul>
</li>
</ul>
<p><strong>当 $p$ 为质数时，可以用快速幂求逆元的推导：</strong></p>
<p>$$a / b ≡ a * x \ (mod \ p)$$ </p>
<p>两边同乘 $b$ 可得 $a ≡ a * b * x \ (mod \ p)$ </p>
<p>同除 $a$ 即 $1 ≡ b * x \ (mod \ p)$ </p>
<p> $b * x ≡ 1 \ (mod \ p)$ </p>
<p>由费马小定理可知，当 $p$ 为质数时</p>
<p>$b ^ {n - 1} ≡ 1 \ (mod \ p)$ </p>
<p>拆一个 $b$ 出来可得 $b * b ^ {n - 2} ≡ 1 \ (mod \ p)$ </p>
<p>故当 $p$ 为质数时，$b$的乘法逆元 $x = b ^ {p - 2}$ </p>
<p>模版题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/878/">AcWing 875. 快速幂求逆元</a> </p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b % p == <span class="number">0</span>) <span class="comment">// b能整除p说明，b和p不互质，即 b mod p的逆元不存在</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qmi</span>(b, p<span class="number">-2</span>, p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p><strong>当 $p$ 不是质数时，用扩展欧几里得算法求逆元：</strong></p>
<p>$b$ 有逆元的充要条件是 $b$ 与 $p$ 互质，所以 $gcd(b, p) = 1$</p>
<p>假设 $b$ 的逆元为 $x$，那么有 $b * x ≡ 1 \ (mod \ p)$</p>
<p>等价： $bx + py = 1$ </p>
<p>$exgcd(b, p, x, y)$ </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) cout &lt;&lt; ((LL)x + p) % p; 当且仅当 (a,p)=<span class="number">1</span> 时有解。</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>求一元线性同余方程组</p>
<p><strong>定义：</strong></p>
<p>给定一组线性同余方程组，求出 $x$ 最小非负整数解：<br>                                                                $$x≡a_1 \ mod \ m_1 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                $$x≡a_2 \ mod \ m_2 $$<br>                                                                            $$⋮ $$<br>                                                                            $$⋮ $$<br>                                                                $$x≡a_n \ mod \ m_n$$</p>
<blockquote>
<p>  <strong>中国剩余定理：</strong></p>
<p>  设 $M=m_1 \times m_2 \times … \times m_n = \prod_{i=1}^{n}{m_i}$ ，$M_i=\frac{M}{m_i}$ 是除了<em>m</em>i以外的<em>n</em>- 1个整数的乘积，$M_i^{-1}$ 是 $M_i$ 模 $m_i$ 意义下的逆元。</p>
<p>  则方程组的通解为</p>
<p>   $x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_nM_nM_n^{-1}+kM=kM+\sum_{i=1}^{n}a_iM_iM_i^{-1},k∈Z$ </p>
<p>  在模 $M$ 的意义下，方程组只有一个解：<br>                                                                               $$x=(\sum^{n}_{i=1}a_iM_iM_i^{-1}) \ mod \ M$$</p>
<p>即：<br>                                                                                  $$x=(\sum^{n}_{i=1}a_i \frac{M}{m_i} (\frac{M}{m_i})^{-1}) \ mod \ M$$</p>
</blockquote>
<p>思路：将多个方程组合为一个方程来求解，即将两个线性同余方程合为一个，以此类推。</p>
<p>推导：</p>
<p>首先考虑前两个线性同余方程：<br>                                                                                        $$x≡a_1 \ mod \ m_1$$<br>​                                                                                        $$x≡a_2 \ mod \ m_2$$ </p>
<p>转化为：<br>                                                                                        $$x=m_1⋅k_1+a_1$$<br>                                                                                        $$x=m_2⋅k_2+a_2$$ </p>
<p>将这两个方程合并移项，可得：<br>                                                                                        $$m_1⋅k_1−m_2⋅k_2=a_2−a_1$$</p>
<p> 即：<br>                                                                                        $$m_1⋅k_1+m_2⋅(-k_2)=a_2−a_1$$</p>
<p><strong>这个方程有解必须满足：</strong><br>                                                                                        $$(a_2-a_1)\ % \ d==0$$</p>
<p>若有解，我们可以通过求<strong>线性同余方程的通解</strong>来得出<br>                                                                                        $$k_1=k_1+\frac{m_2}{d} \cdot k \ ,k∈Z$$<br>                                                                                        $$k_2=k_2+\frac{m_1}{d} \cdot k \ , k∈Z$$</p>
<p>将 $k_1$ 带回 $x=m_1 \cdot k_1 +a_1$ 得：<br>                                                                                        $$x=k_1 \cdot m_1 +a_1$$<br>                                                                                        $$x=(k_1+k \cdot \frac{m_2}{d}) \cdot m_1 + a_1$$</p>
<p>展开：<br>                                                                                        $$x=\frac{m_1m_2}{d} \cdot k+k_1m_1+a_1$$</p>
<p>$\frac{m_1m_2}{d}$ 为 $m_1$ 和 $m_2$  的最小公倍数，即：<br>                                                                                        $$x=[m_1,m_2] \cdot k+k_1m_1+a_1 \ ①$$</p>
<p>可以发现上面的方程与这方程相类似<br>                                                                                        $$x=m⋅k+a$$</p>
<p>对比发现：<br>                                                                                        $$m=[m_1,m_2]$$<br>                                                                                        $$a=k_1m_1+a_1$$</p>
<p>将得到的方程①与下一个同余方程合并，直到最后只剩一个方程时：$x=m \cdot k+a$</p>
<p>即求：<br>                                                                                        $$x \ mod \ m ≡ a$$</p>
<p>即求：<br>                                                                                        $$x=a \ mod \ m$$</p>
<p>最后直接用合并后方程的 $a$ 和 $m$ 求一个最小正整数解即可： $(a % m +m )%m$ </p>
<p>思路就是按照推导过程去实现</p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/206/">AcWing 204. 表达整数的奇怪方式</a></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LL n, a1, a2, k1, k2, m1, m2;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; m1 &gt;&gt; a1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; m2 &gt;&gt; a2;</span><br><span class="line">    LL d = <span class="built_in">exgcd</span>(m1, -m2, k1, k2); <span class="comment">// 求得 k1*m1 + k2*(-m2) = d</span></span><br><span class="line">    <span class="keyword">if</span>((a2 - a1) % d) <span class="comment">// 不能整除则无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  求出的是 k1*m1 + k2*m2 = d ，我们需要求的是右边是 a2-a1的值</span></span><br><span class="line"><span class="comment">        因为 d 与 a2-a1 是倍数，所以两边翻(a2-a1)/d倍即可，</span></span><br><span class="line"><span class="comment">        k2不需要翻倍的原因是，不需要用到</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    k1 *= (a2 - a1) / d; <span class="comment">//翻若干倍</span></span><br><span class="line">    LL t = m2 / d; <span class="comment">// k1的通解：k1=k1+m2/d*k ，k∈Z</span></span><br><span class="line">    k1 = (k1 % t + t) % t; <span class="comment">// 将k1变成最小的正整数解</span></span><br><span class="line"></span><br><span class="line">    a1+= k1 * m1; <span class="comment">// a=k1*m1+a1 得先求了a1才能求m1,不然m1值变了</span></span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">abs</span>(m1 / d * m2); <span class="comment">// m=[m1,m2] 最小公倍数数，有可能是负的，这里求一个正的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (a1 % m1 + m1) % m1 &lt;&lt; endl; <span class="comment">//结果就是x = a mod m ，但这里求一个最小正整数解</span></span><br></pre></td></tr></table></figure>





<h1 id="高斯消元解线性方程"><a href="#高斯消元解线性方程" class="headerlink" title="高斯消元解线性方程"></a>高斯消元解线性方程</h1><p>思路：</p>
<ul>
<li>枚举每一列 $c$ <ol>
<li>  找到绝对值最大的一行</li>
<li>  将该行换到最上面</li>
<li>  （倒着算）将该行该列的这个数变成 1</li>
<li>  （从上往下）将下面所有行的第 $c$ 列消成 0</li>
</ol>
</li>
<li>  判断是否有解 或 为无穷解</li>
<li>（从下往上）将上面所有行的第 $c$ 列消成 0<ul>
<li>枚举每一列<ul>
<li>  枚举每一行（倒着算）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h1><p>红线代表曼哈顿距离，绿色代表<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB">欧氏距离</a>，也就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB">直线距离</a>，而蓝色和黄色代表等价的曼哈顿距离。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF">曼哈顿</a>距离——两点在南北方向上的距离加上在东西方向上的距离，即 $d(i,j)=|x_i-x_j|+|y_i-y_j|$ 。曼哈顿距离又称为出租车距离。</p>
<img src="http://duegin.gitee.io/pic/pictures/4.数论/曼哈顿距离.png" alt="曼哈顿距离" style="zoom: 67%;">

<p>曼哈顿距离包括终点本身</p>
<p><strong>都是整数</strong></p>
<h1 id="欧几里得距离"><a href="#欧几里得距离" class="headerlink" title="欧几里得距离"></a>欧几里得距离</h1><p>两点之间的距离，也称<strong>欧氏距离</strong></p>
<p>这个就是高中二维和三维坐标系所学的</p>
<p><strong>有浮点数</strong></p>
<p>二维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$$ </p>
<p>三维：</p>
<p>$$\rho =\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}$$ </p>
<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="Ⅰ-O-N-2"><a href="#Ⅰ-O-N-2" class="headerlink" title="Ⅰ $O(N^2)$"></a>Ⅰ $O(N^2)$</h2><p>10万组询问，$1≤m≤n≤2000$，$p=10^9 + 7$</p>
<p>$C_n^m=C_{n-1}^{m}+C_{n-1}^{m-1}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="comment">// 从i个中选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 选j个</span></span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>; <span class="comment">// 从i个中选0个，方案数为1</span></span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DP预处理出$C_{0 … N - 1}^{0 … N - 1}$的所有情况</p>
<h2 id="Ⅱ-O-NlogN"><a href="#Ⅱ-O-NlogN" class="headerlink" title="Ⅱ $O(NlogN)$"></a>Ⅱ $O(NlogN)$</h2><p>1万组询问，$1≤m≤n≤1e5$，$p=10^9 + 7$</p>
<p>$$C_{n}^{m}=\frac{n!}{m!(n-m)!}$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        t = (LL)t * t % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C_&#123;a&#125;^&#123;b&#125; resul</span></span><br><span class="line">cout &lt;&lt; (LL)fact[a] * infact[a - b] % mod * infact[b] % mod &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>预处理出所有情况</p>
<h2 id="Ⅲ-Lucas定理-O-p-cdot-log-pN-cdot-log-p"><a href="#Ⅲ-Lucas定理-O-p-cdot-log-pN-cdot-log-p" class="headerlink" title="Ⅲ Lucas定理$O(p \cdot log_pN \cdot log\ p )$"></a>Ⅲ Lucas定理$O(p \cdot log_pN \cdot log\ p )$</h2><p>20组(少量)询问，$1≤m≤n≤10^{18}$，$1≤p≤10^5$</p>
<p>$$C_{n}^{m}≡C_{n % p}^{m % p} \cdot C_{n / p}^{m / p} \ (mod \ p)$$</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
            <a href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag"># 数论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/12/21/%E7%AE%97%E6%B3%95/3.%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="next" title="二分图">
                <i class="fa fa-chevron-left"></i> 二分图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/01/14/%E7%AE%97%E6%B3%95/1.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/%E7%A6%BB%E6%95%A3%E5%8C%96/" rel="prev" title="离散化">
                离散化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Rin.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DueGin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">数论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">质数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">试除法判定质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">试除法分解质因数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">埃氏筛法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">线性筛法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">约数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E6%89%80%E6%9C%89%E7%BA%A6%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">试除法求所有约数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">约数个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.3.</span> <span class="nav-text">约数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">最大公约数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">欧几里得算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stein%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">Stein算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF"><span class="nav-number">3.4.3.</span> <span class="nav-text">更相减损术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="nav-number">3.4.4.</span> <span class="nav-text">区间最大公约数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">最小公倍数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">求欧拉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E6%B1%82%E6%B3%95"><span class="nav-number">3.6.1.</span> <span class="nav-text">朴素求法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.2.</span> <span class="nav-text">筛法求欧拉函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">4.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">扩展欧几里得算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">线性同余方程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E9%80%86%E5%85%83"><span class="nav-number">6.</span> <span class="nav-text">求逆元</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">高斯消元解线性方程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB"><span class="nav-number">9.</span> <span class="nav-text">曼哈顿距离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB"><span class="nav-number">10.</span> <span class="nav-text">欧几里得距离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">组合数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A0-O-N-2"><span class="nav-number">11.1.</span> <span class="nav-text">Ⅰ $O(N^2)$</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A1-O-NlogN"><span class="nav-number">11.2.</span> <span class="nav-text">Ⅱ $O(NlogN)$</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%85%A2-Lucas%E5%AE%9A%E7%90%86-O-p-cdot-log-pN-cdot-log-p"><span class="nav-number">11.3.</span> <span class="nav-text">Ⅲ Lucas定理$O(p \cdot log_pN \cdot log\ p )$</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DueGin</span>

  
</div>







<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
